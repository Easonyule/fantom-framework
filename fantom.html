<h1 id="ch:intro">Introduction</h1>
<p>Blockchain has emerged as a technology for secure decentralized transaction ledgers with broad applications in financial systems, supply chains and health care. <em>Byzantine</em> fault tolerance <span class="citation"></span> is addressed in distributed database systems, in which up to one-third of the participant nodes may be compromised. Consensus algorithms <span class="citation"></span> ensures the integrity of transactions between participants over a distributed network <span class="citation"></span> and is equivalent to the proof of <em>Byzantine</em> fault tolerance in distributed database systems <span class="citation"></span>.</p>
<p>A large number of consensus algorithms have been proposed. For example; the original Nakamoto consensus protocol in Bitcoin uses Proof of Work (PoW) <span class="citation"></span>. Proof Of Stake (PoS) <span class="citation"></span> uses participants’ stakes to generate the blocks respectively. Our previous paper gives a survey of previous DAG-based approaches <span class="citation"></span>.</p>
<p>In the previous paper <span class="citation"></span>, we introduced a new consensus protocol, called <span class="math inline"><em>L</em><sub>0</sub></span>. The protocol <span class="math inline"><em>L</em><sub>0</sub></span> is a DAG-based asynchronous non-deterministic protocol that guarantees pBFT. <span class="math inline"><em>L</em><sub>0</sub></span> generates each block asynchronously and uses the OPERA chain (DAG) for faster consensus by confirming how many nodes share the blocks.</p>
<p>The Lachesis protocol as previously proposed is a set of protocols that create a directed acyclic graph for distributed systems. Each node can receive transactions and batch them into an event block. An event block is then shared with it’s peers. When peers communicate they share this information again and thus spread this information through the network. In BFT systems we would use a broadcast voting approach and ask each node to vote on the validity of each block. This event is synchronous in nature. Instead we proposed an asynchronous system where we leverage the concepts of distributed common knowledge, dominator relations in graph theory and broadcast based gossip to achieve a local view with high probability of being a global view. It accomplishes this asynchronously, meaning that we can increase throughput near linearly as nodes enter the network.</p>
<p>In this work, we propose a further enhancement on these concepts and we formalize them so that they can be applied to any asynchronous distributed system.</p>
<h2 id="contributions">Contributions</h2>
<p>In summary, this paper makes the following contributions:</p>
<ul>
<li><p>We introduce the n-row flag table for faster root selection of the Lachesis Protocol</p></li>
<li><p>We define continuous consistent cuts of a local view to achieve consensus</p></li>
<li><p>We present proof of how domination relationships can be used for share information</p></li>
<li><p>We formalize our proofs that can be applied to any generic asynchronous DAG solution</p></li>
</ul>
<h2 id="paper-structure">Paper structure</h2>
<p>The rest of this paper is organised as follows. Section [se:prelim] describes our Fantom framework. Section [se:lca] presents the protocol implementation. Section [se:con] concludes our paper with some future directions. Proof of Byzantine fault tolerance is described in Section [se:proof].</p>
<h1 id="se:prelim">Preliminaries</h1>
<p>The protocol is run via nodes representing users’ machines which together create a network. The basic units of the protocol are called event blocks - a data structure created by a single node to share transaction and user information with the rest of the network. These event blocks reference previous event blocks that are known to the node. This flow or stream of information creates a sequence of history.</p>
<p>The history of the protocol can be represented by a directed acyclic graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>, where <span class="math inline"><em>V</em></span> is a set of vertices and <span class="math inline"><em>E</em></span> is a set of edges. Each vertex in a row (node) represents an event. Time flows left-to-right of the graph, so left vertices represent earlier events in history.</p>
<p>For a graph <span class="math inline"><em>G</em></span>, a path <span class="math inline"><em>p</em></span> in <span class="math inline"><em>G</em></span> is a sequence of vertices (<span class="math inline"><em>v</em><sub>1</sub></span>, <span class="math inline"><em>v</em><sub>2</sub></span>, <span class="math inline">…</span>, <span class="math inline"><em>v</em><sub><em>k</em></sub></span>) by following the edges in <span class="math inline"><em>E</em></span>. Let <span class="math inline"><em>v</em><sub><em>c</em></sub></span> be a vertex in <span class="math inline"><em>G</em></span>. A vertex <span class="math inline"><em>v</em><sub><em>p</em></sub></span> is the <em>parent</em> of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is an edge from <span class="math inline"><em>v</em><sub><em>p</em></sub></span> to <span class="math inline"><em>v</em><sub><em>c</em></sub></span>. A vertex <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is an <em>ancestor</em> of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a path from <span class="math inline"><em>v</em><sub><em>a</em></sub></span> to <span class="math inline"><em>v</em><sub><em>c</em></sub></span>.</p>
<div class="figure">
<embed src="OPERA_chain.pdf" height="188" />
<p class="caption">An Example of OPERA Chain<span data-label="fig:operachain"></span></p>
</div>
<p>Figure [fig:operachain] shows an example of an OPERA chain (DAG) constructed through the Lachesis protocol. Event blocks are representated by circles. Blocks of the same frame have the same color.</p>
<h2 id="basic-definitions">Basic Definitions</h2>
<p><span><span class="math inline"> </span> <strong><em>(Lachesis)</em></strong> <span>The set of <em>protocols</em></span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Node)</em></strong> <span>Each machine that participates in the Lachesis protocol is called a <em>node</em>. Let <span class="math inline"><em>n</em></span> denote the total number of nodes.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(<span class="math inline"><em>k</em></span>)</em></strong> <span>A <em>constant</em> defined in the system.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Peer node)</em></strong> <span>A node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> has <span class="math inline"><em>k</em></span> <em>peer nodes</em>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Process)</em></strong> <span>A process <span class="math inline"><em>p</em><sub><em>i</em></sub></span> represents a machine or a <em>node</em>. The process identifier of <span class="math inline"><em>p</em><sub><em>i</em></sub></span> is <span class="math inline"><em>i</em></span>. A set <span class="math inline"><em>P</em></span> = {1,...,<span class="math inline"><em>n</em></span>} denotes the set of process identifiers.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Channel)</em></strong> <span>A process <span class="math inline"><em>i</em></span> can send messages to process <span class="math inline"><em>j</em></span> if there is a channel (<span class="math inline"><em>i</em></span>,<span class="math inline"><em>j</em></span>). Let <span class="math inline"><em>C</em></span> <span class="math inline">⊆</span> {(<span class="math inline"><em>i</em></span>,<span class="math inline"><em>j</em></span>) s.t. <span class="math inline"><em>i</em>, <em>j</em> ∈ <em>P</em></span>} denote the set of channels.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Event block)</em></strong> <span>Each node can create event blocks, send (receive) messages to (from) other nodes.The structure of an event block includes the signature, generation time, transaction history, and hash information to references.</span></span></p>
<p>All nodes can create event blocks. The information of the referenced event blocks can be copied by each node. The first event block of each node is called a <em>leaf event</em>.</p>
<p>Suppose a node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> creates an event <span class="math inline"><em>v</em><sub><em>c</em></sub></span> after an event <span class="math inline"><em>v</em><sub><em>s</em></sub></span> in <span class="math inline"><em>n</em><sub><em>i</em></sub></span>. Each event block has exactly <span class="math inline"><em>k</em></span> references. One of the references is self-reference, and the other <span class="math inline"><em>k</em></span>-1 references point to the top events of <span class="math inline"><em>n</em><sub><em>i</em></sub></span>’s <span class="math inline"><em>k</em></span>-1 peer nodes.</p>
<p><span><span class="math inline"> </span> <strong><em>(Top event)</em></strong> <span>An event <span class="math inline"><em>v</em></span> is a top event of a node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> if there is no other event in <span class="math inline"><em>n</em><sub><em>i</em></sub></span> referencing <span class="math inline"><em>v</em></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Height Vector)</em></strong> <span>The height vector is the number of event blocks <em>created</em> by the <span class="math inline"><em>i</em><sup><em>t</em><em>h</em></sup></span> node.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(In-degree Vector)</em></strong> <span>The in-degree vector refers to the number of <em>edges</em> from other event blocks created by other nodes to the top event block of this node. The top event block indicates the most recently created event block by this node.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Ref)</em></strong> <span>An event <span class="math inline"><em>v</em><sub><em>r</em></sub></span> is called “ref&quot; of event <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if the reference hash of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> points to the event <span class="math inline"><em>v</em><sub><em>r</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>r</em></sup><em>v</em><sub><em>r</em></sub></span>. For simplicity, we can use <span class="math inline">↪</span> to denote a reference relationship (either <span class="math inline">↪<sup><em>r</em></sup></span> or <span class="math inline">↪<sup><em>s</em></sup></span>).</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Self-ref)</em></strong> <span>An event <span class="math inline"><em>v</em><sub><em>s</em></sub></span> is called “self-ref&quot; of event <span class="math inline"><em>v</em><sub><em>c</em></sub></span>, if the self-ref hash of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> points to the event <span class="math inline"><em>v</em><sub><em>s</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>s</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(<span class="math inline"><em>k</em></span> references)</em></strong> <span>Each event block has at least <span class="math inline"><em>k</em></span> references. One of the references is self-reference, and the other <span class="math inline"><em>k</em></span>-1 references point to the top events of <span class="math inline"><em>n</em><sub><em>i</em></sub></span>’s <span class="math inline"><em>k</em></span>-1 peer nodes.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Self-ancestor)</em></strong> <span>An event block <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is self-ancestor of an event block <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a sequence of events such that <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em></sup><em>v</em><sub>1</sub>↪<sup><em>s</em></sup>…↪<sup><em>s</em></sup><em>v</em><sub><em>m</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>a</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em><em>a</em></sup><em>v</em><sub><em>a</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Ancestor)</em></strong> <span>An event block <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is an ancestor of an event block <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a sequence of events such that <span class="math inline"><em>v</em><sub><em>c</em></sub> ↪ <em>v</em><sub>1</sub> ↪ … ↪ <em>v</em><sub><em>m</em></sub> ↪ <em>v</em><sub><em>a</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>a</em></sub></span>.</span></span></p>
<p>For simplicity, we simply use <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>s</em></sub></span> to refer both ancestor and self-ancestor relationship, unless we need to distinguish the two cases.</p>
<p><span><span class="math inline"> </span> <strong><em>(Flag Table)</em></strong> <span>The flag table is a <span class="math inline"><em>n</em><em>x</em><em>k</em></span> matrix, where n is the number of nodes and k is the number of roots that an event block can reach. If an event block <span class="math inline"><em>e</em></span> created by <span class="math inline"><em>i</em><sup><em>t</em><em>h</em></sup></span> node can reach <span class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span> root, then the flag table stores the hash value of the <span class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span> root.</span></span></p>
<h2 id="lamport-timestamps">Lamport timestamps</h2>
<p>Our Lachesis protocols relies on Lamport timestamps to define a topological ordering of event blocks in OPERA chain. By using Lamport timestamps, we do not rely on physical clocks to determine a partial ordering of events.</p>
<p>The “happened before“ relation, denoted by <span class="math inline">→</span>, gives a partial ordering of events from a distributed system of nodes. Each node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> (also called a process) is identified by its process identifier <span class="math inline"><em>i</em></span>. For a pair of event blocks <span class="math inline"><em>v</em></span> and <span class="math inline"><em>v</em>′</span>, the relation ”<span class="math inline">→</span>&quot; satisfies: (1) If <span class="math inline"><em>v</em></span> and <span class="math inline"><em>v</em>′</span> are events of process <span class="math inline"><em>P</em><sub><em>i</em></sub></span>, and <span class="math inline"><em>v</em></span> comes before <span class="math inline"><em>v</em>′</span>, then <span class="math inline"><em>b</em> → <em>v</em>′</span>. (2) If <span class="math inline"><em>v</em></span> is the send(<span class="math inline"><em>m</em></span>) by one process and <span class="math inline"><em>v</em>′</span> is the receive(<span class="math inline"><em>m</em></span>) by another process, then <span class="math inline"><em>v</em> → <em>v</em>′</span>. (3) If <span class="math inline"><em>v</em> → <em>v</em>′</span> and <span class="math inline"><em>v</em>′→<em>v</em>″</span> then <span class="math inline"><em>v</em> → <em>v</em>″</span>. Two distinct events <span class="math inline"><em>v</em></span> and <span class="math inline"><em>v</em>′</span> are said to be concurrent if <span class="math inline"><em>v</em> ↛ <em>v</em>′</span> and <span class="math inline"><em>v</em>′↛<em>v</em></span>.</p>
<p>For an arbitrary total ordering <span class="math inline">≺</span> of the processes, a relation <span class="math inline">⇒</span> is defined as follows: if <span class="math inline"><em>v</em></span> is an event in process <span class="math inline"><em>P</em><sub><em>i</em></sub></span> and <span class="math inline"><em>v</em>′</span> is an event in process <span class="math inline"><em>P</em><sub><em>j</em></sub></span>, then <span class="math inline"><em>v</em> ⇒ <em>v</em>′</span> if and only if either (i) <span class="math inline"><em>C</em><sub><em>i</em></sub>(<em>v</em>)&lt;<em>C</em><sub><em>j</em></sub>(<em>v</em>′)</span> or (ii) <span class="math inline"><em>C</em>(<em>v</em>)=<em>C</em><sub><em>j</em></sub>(<em>v</em>′)</span> and <span class="math inline"><em>P</em><sub><em>i</em></sub> ≺ <em>P</em><sub><em>j</em></sub></span>. This defines a total ordering, and that the Clock Condition implies that if <span class="math inline"><em>v</em> → <em>v</em>′</span> then <span class="math inline"><em>v</em> ⇒ <em>v</em>′</span>.</p>
<p>We use this total ordering in our Lachesis protocol. This ordering is used to determine consensus time, as described in Section [se:lca].</p>
<p><span><span class="math inline"> </span> <strong><em>(Happened-Immediate-Before)</em></strong> <span>An event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is said Happened-Immediate-Before an event block <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a (self-) ref of <span class="math inline"><em>v</em><sub><em>y</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ↦ <em>v</em><sub><em>y</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Happened-before)</em></strong> <span>An event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is said Happened-Before an event block <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a (self-) ancestor of <span class="math inline"><em>v</em><sub><em>y</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span>.</span></span></p>
<p>Happened-before is the relationship between nodes which have event blocks. If there is a path from an event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span> to <span class="math inline"><em>v</em><sub><em>y</em></sub></span>, then <span class="math inline"><em>v</em><sub><em>x</em></sub></span> Happened-before <span class="math inline"><em>v</em><sub><em>y</em></sub></span>. “<span class="math inline"><em>v</em><sub><em>x</em></sub></span> Happened-before <span class="math inline"><em>v</em><sub><em>y</em></sub></span>&quot; means that the node creating <span class="math inline"><em>v</em><sub><em>y</em></sub></span> knows event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. This relation is the transitive closure of happens-immediately-before. Thus, an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> happened before an event <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if one of the followings happens: (a) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>x</em></sub></span>, (b) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>r</em></sup><em>v</em><sub><em>x</em></sub></span>, or (c) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>x</em></sub></span>. The happened-before relation of events form an acyclic directed graph <span class="math inline"><em>G</em>′=(<em>V</em>, <em>E</em>′)</span> such that an edge <span class="math inline">(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)∈<em>E</em>′</span> has a reverse direction of the same edge in <span class="math inline"><em>E</em></span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Concurrent)</em></strong> <span>Two event blocks <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> are said concurrent if neither of them happened before the other. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span>.</span></span></p>
<p>Given two vertices <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> both contained in two OPERA chains (DAGs) <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> on two nodes. We have the following:<br />
(1) <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>;<br />
(2)<span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>.</p>
<h2 id="state-definitions">State Definitions</h2>
<p>Each node has a local state, a collection of histories, messages, event blocks, and peer information, we describe the components of each.</p>
<p><span><span class="math inline"> </span> <strong><em>(State)</em></strong> <span>A state of a process <span class="math inline"><em>i</em></span> is denoted by <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Local State)</em></strong> <span>A local state consists of a sequence of event blocks <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup> = <em>v</em><sub>0</sub><sup><em>i</em></sup>, <em>v</em><sub>1</sub><sup><em>i</em></sup>, …, <em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</span></span></p>
<p>In a DAG-based protocol, each <span class="math inline"><em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span> event block is valid only if the reference blocks exist before it. From a local state <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span>, one can reconstruct a unique DAG. That is, the mapping from a local state <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span> into a DAG is <em>injective</em> or one-to-one. Thus, for Fantom, we can simply denote the <span class="math inline"><em>j</em></span>-th local state of a process <span class="math inline"><em>i</em></span> by the DAG <span class="math inline"><em>g</em><sub><em>j</em></sub><sup><em>i</em></sup></span> (often we simply use <span class="math inline"><em>G</em><sub><em>i</em></sub></span> to denote the current local state of a process <span class="math inline"><em>i</em></span>).</p>
<p><span><span class="math inline"> </span> <strong><em>(Action)</em></strong> <span>An action is a function from one local state to another local state.</span></span></p>
<p>Generally speaking, an action can be one of: a <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em>)</span> action where <span class="math inline"><em>m</em></span> is a message, a <span class="math inline"><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em>(<em>m</em>)</span> action, and an internal action. A message <span class="math inline"><em>m</em></span> is a triple <span class="math inline">⟨<em>i</em>, <em>j</em>, <em>B</em>⟩</span> where <span class="math inline"><em>i</em> ∈ <em>P</em></span> is the sender of the message, <span class="math inline"><em>j</em> ∈ <em>P</em></span> is the message recipient, and <span class="math inline"><em>B</em></span> is the body of the message. Let <span class="math inline"><em>M</em></span> denote the set of messages. In the Lachesis protocol, <span class="math inline"><em>B</em></span> consists of the content of an event block <span class="math inline"><em>v</em></span>.<br />
Semantics-wise, in Lachesis, there are two actions that can change a process’s local state: creating a new event and receiving an event from another process.<br />
<span><span class="math inline"> </span> <strong><em>(Event)</em></strong> <span>An event is a tuple <span class="math inline">⟨<em>s</em>, <em>α</em>, <em>s</em>′⟩</span> consisting of a state, an action, and a state. Sometimes, the event can be represented by the end state <span class="math inline"><em>s</em>′</span>.</span></span></p>
<p>The <span class="math inline"><em>j</em></span>-th event in history <span class="math inline"><em>h</em><sub><em>i</em></sub></span> of process <span class="math inline"><em>i</em></span> is <span class="math inline">⟨<em>s</em><sub><em>j</em> − 1</sub><sup><em>i</em></sup>, <em>α</em>, <em>s</em><sub><em>j</em></sub><sup><em>i</em></sup>⟩</span>, denoted by <span class="math inline"><em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Local history)</em></strong> <span>A local history <span class="math inline"><em>h</em><sub><em>i</em></sub></span> of process <span class="math inline"><em>i</em></span> is a (possibly infinite) sequence of alternating local states — beginning with a distinguished initial state. A set <span class="math inline"><em>H</em><sub><em>i</em></sub></span> of possible local histories for each process <span class="math inline"><em>i</em></span> in <span class="math inline"><em>P</em></span>.</span></span></p>
<p>The state of a process can be obtained from its initial state and the sequence of actions or events that have occurred up to the current state. In the Lachesis protocol, we use append-only semantics. The local history may be equivalently described as either of the following: <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>α</em><sub>1</sub><sup><em>i</em></sup>, <em>α</em><sub>2</sub><sup><em>i</em></sup>, <em>α</em><sub>3</sub><sup><em>i</em></sup>…</span><br /> <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>v</em><sub>1</sub><sup><em>i</em></sup>, <em>v</em><sub>2</sub><sup><em>i</em></sup>, <em>v</em><sub>3</sub><sup><em>i</em></sup>…</span><br /> <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>s</em><sub>1</sub><sup><em>i</em></sup>, <em>s</em><sub>2</sub><sup><em>i</em></sup>, <em>s</em><sub>3</sub><sup><em>i</em></sup>, …</span><br /></p>
<p>In Lachesis, a local history is equivalently expressed as: <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>g</em><sub>0</sub><sup><em>i</em></sup>, <em>g</em><sub>1</sub><sup><em>i</em></sup>, <em>g</em><sub>2</sub><sup><em>i</em></sup>, <em>g</em><sub>3</sub><sup><em>i</em></sup>, …</span><br /> where <span class="math inline"><em>g</em><sub><em>j</em></sub><sup><em>i</em></sup></span> is the <span class="math inline"><em>j</em></span>-th local DAG (local state) of the process <span class="math inline"><em>i</em></span>. <span><span class="math inline"> </span> <strong><em>(Run)</em></strong> <span>Each asynchronous run is a vector of local histories. Denoted by <span class="math inline"><em>σ</em> = ⟨<em>h</em><sub>1</sub>, <em>h</em><sub>2</sub>, <em>h</em><sub>3</sub>, ...<em>h</em><sub><em>N</em></sub>⟩</span>.</span></span></p>
<p>Let <span class="math inline"><em>Σ</em></span> denote the set of asynchronous runs. We can now use Lamport’s theory to talk about global states of an asynchronous system. A global state of run <span class="math inline"><em>σ</em></span> is an <span class="math inline"><em>n</em></span>-vector of prefixes of local histories of <span class="math inline"><em>σ</em></span>, one prefix per process. The happens-before relation can be used to define a consistent global state, often termed a consistent cut, as follows.</p>
<h2 id="consistent-cut">Consistent Cut</h2>
<p>Consistent cuts represent the concept of scalar time in distributed computation, it is possible to distinguish between a “before&quot; and an “after&quot;</p>
<p>In the Lachesis protocol, an OPERA chain <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> is a directed acyclic graph (DAG). <span class="math inline"><em>V</em></span> is a set of vertices and <span class="math inline"><em>E</em></span> is a set of edges. DAG is a directed graph with no cycle. There is no path that has source and destination at the same vertex. A path is a sequence of vertices (<span class="math inline"><em>v</em><sub>1</sub></span>, <span class="math inline"><em>v</em><sub>2</sub></span>, ..., <span class="math inline"><em>v</em><sub><em>k</em> − 1</sub></span>, <span class="math inline"><em>v</em><sub><em>k</em></sub></span>) that uses no edge more than once.</p>
<p>An asynchronous system consists of the following sets: a set <span class="math inline"><em>P</em></span> of process identifiers; a set <span class="math inline"><em>C</em></span> of channels; a set <span class="math inline"><em>H</em><sub><em>i</em></sub></span> is the set of possible local histories for each process <span class="math inline"><em>i</em></span>; a set <span class="math inline"><em>A</em></span> of asynchronous runs; a set <span class="math inline"><em>M</em></span> of all messages.</p>
<p>Each process / node in Lachesis selects <span class="math inline"><em>k</em></span> other nodes as peers. For certain gossip protocol, nodes may be constrained to gossip with its <span class="math inline"><em>k</em></span> peers. In such a case, the set of channels <span class="math inline"><em>C</em></span> can be modelled as follows. If node <span class="math inline"><em>i</em></span> selects node <span class="math inline"><em>j</em></span> as a peer, then <span class="math inline">(<em>i</em>, <em>j</em>)∈<em>C</em></span>. In general, one can express the history of each node in DAG-based protocol in general or in Lachesis protocol in particular, in the same manner as in the CCK paper <span class="citation"></span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Consistent cut)</em></strong> <span>A consistent cut of a run <span class="math inline"><em>σ</em></span> is any global state such that if <span class="math inline"><em>v</em><sub><em>x</em></sub><sup><em>i</em></sup> → <em>v</em><sub><em>y</em></sub><sup><em>j</em></sup></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub><sup><em>j</em></sup></span> is in the global state, then <span class="math inline"><em>v</em><sub><em>x</em></sub><sup><em>i</em></sup></span> is also in the global state. Denoted by <span class="math inline"><strong>c</strong>(<em>σ</em>)</span>.</span></span></p>
<p>The concept of consistent cut formalizes such a global state of a run. A consistent cut consists of all consistent DAG chains. A received event block exists in the global state implies the existence of the original event block. Note that a consistent cut is simply a vector of local states; we will use the notation <span class="math inline"><strong>c</strong>(<em>σ</em>)[<em>i</em>]</span> to indicate the local state of <span class="math inline"><em>i</em></span> in cut <span class="math inline"><strong>c</strong></span> of run <span class="math inline"><em>σ</em></span>.</p>
<p>A message chain of an asynchronous run is a sequence of messages <span class="math inline"><em>m</em><sub>1</sub></span>, <span class="math inline"><em>m</em><sub>2</sub></span>, <span class="math inline"><em>m</em><sub>3</sub></span>, <span class="math inline">…</span>, such that, for all <span class="math inline"><em>i</em></span>, <span class="math inline"><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em>(<em>m</em><sub><em>i</em></sub>)</span> <span class="math inline">→</span> <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em><sub><em>i</em> + 1</sub>)</span>. Consequently, <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em><sub>1</sub>)</span> <span class="math inline">→</span> <span class="math inline"><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em>(<em>m</em><sub>1</sub>)</span> <span class="math inline">→</span> <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em><sub>2</sub>)</span> <span class="math inline">→</span> <span class="math inline"><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em>(<em>m</em><sub>2</sub>)</span> <span class="math inline">→</span> <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em><sub>3</sub>)</span> <span class="math inline">…</span>.</p>
<p>The formal semantics of an asynchronous system is given via the satisfaction relation <span class="math inline">⊢</span>. Intuitively <span class="math inline"><strong>c</strong>(<em>σ</em>)⊢<em>ϕ</em></span>, “<span class="math inline"><strong>c</strong>(<em>σ</em>)</span> satisfies <span class="math inline"><em>ϕ</em></span>,” if fact <span class="math inline"><em>ϕ</em></span> is true in cut <span class="math inline"><strong>c</strong></span> of run <span class="math inline"><em>σ</em></span>.</p>
<p>We assume that we are given a function <span class="math inline"><em>π</em></span> that assigns a truth value to each primitive proposition <span class="math inline"><em>p</em></span>. The truth of a primitive proposition <span class="math inline"><em>p</em></span> in <span class="math inline"><strong>c</strong>(<em>σ</em>)</span> is determined by <span class="math inline"><em>π</em></span> and <span class="math inline"><strong>c</strong></span>. This defines <span class="math inline"><strong>c</strong>(<em>σ</em>)⊢<em>p</em></span>.<br />
<span><span class="math inline"> </span> <strong><em>(Equivalent cuts)</em></strong> <span>Two cuts <span class="math inline"><strong>c</strong>(<em>σ</em>)</span> and <span class="math inline"><strong>c</strong><strong>′</strong>(<em>σ</em>′)</span> are equivalent with respect to <span class="math inline"><em>i</em></span> if: <br /><span class="math display"><strong>c</strong>(<em>σ</em>)∼<sub><em>i</em></sub><strong>c</strong><strong>′</strong>(<em>σ</em>′) ⇔ <strong>c</strong>(<em>σ</em>)[<em>i</em>]=<strong>c</strong><strong>′</strong>(<em>σ</em>′)[<em>i</em>]</span><br />.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(<span class="math inline"><em>i</em></span> knows <span class="math inline"><em>ϕ</em></span>)</em></strong> <span><span class="math inline"><em>K</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> represents the statement “<span class="math inline"><em>ϕ</em></span> is true in all possible consistent global states that include <span class="math inline"><em>i</em></span>’s local state”. <br /><span class="math display"><strong>c</strong>(<em>σ</em>)⊢<em>K</em><sub><em>i</em></sub>(<em>ϕ</em>)⇔∀<strong>c</strong><strong>′</strong>(<em>σ</em>′)(<strong>c</strong><strong>′</strong>(<em>σ</em>′)∼<sub><em>i</em></sub><strong>c</strong>(<em>σ</em>)  ⇒  <strong>c</strong><strong>′</strong>(<em>σ</em>′) ⊢ <em>ϕ</em>)</span><br /></span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(<span class="math inline"><em>i</em></span> partially knows <span class="math inline"><em>ϕ</em></span>)</em></strong> <span><span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> represents the statement “there is some consistent global state in this run that includes <span class="math inline"><em>i</em></span>’s local state, in which <span class="math inline"><em>ϕ</em></span> is true.” <br /><span class="math display"><strong>c</strong>(<em>σ</em>)⊢<em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)⇔∃<strong>c</strong><strong>′</strong>(<em>σ</em>)(<strong>c</strong><strong>′</strong>(<em>σ</em>)∼<sub><em>i</em></sub><strong>c</strong>(<em>σ</em>)  ∧  <strong>c</strong><strong>′</strong>(<em>σ</em>)⊢<em>ϕ</em>)</span><br /></span></span></p>
<p><span class="math inline"> </span> <strong><em>(Majority concurrently knows)</em></strong></p>
<p>The next modal operator is written <span class="math inline"><em>M</em><sup><em>C</em></sup></span> and stands for “majority concurrently knows.” The definition of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is as follows.</p>
<p><br /><span class="math display"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)=<sub><em>d</em><em>e</em><em>f</em></sub>⋀<sub><em>i</em> ∈ <em>S</em></sub><em>K</em><sub><em>i</em></sub><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>),</span><br /> where <span class="math inline"><em>S</em> ⊆ <em>P</em></span> and <span class="math inline">|<em>S</em>|&gt;2<em>n</em>/3</span>.</p>
<p>This is adapted from the “everyone concurrently knows” in CCK paper <span class="citation"></span>. In the presence of one-third of faulty nodes, the original operator “everyone concurrently knows” is sometimes not feasible. Our modal operator <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> fits precisely the semantics for BFT systems, in which unreliable processes may exist.<br />
<span><span class="math inline"> </span> <strong><em>(Concurrent common knowledge)</em></strong> <span>The last modal operator is concurrent common knowledge (CCK), denoted by <span class="math inline"><em>C</em><sup><em>C</em></sup></span>. <span class="math inline"><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is defined as a fixed point of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span>.</span></span></p>
<p>CCK defines a state of process knowledge that implies that all processes are in that same state of knowledge, with respect to <span class="math inline"><em>ϕ</em></span>, along some cut of the run. In other words, we want a state of knowledge <span class="math inline"><em>X</em></span> satisfying: <span class="math inline"><em>X</em> = <em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span>. <span class="math inline"><em>C</em><sup><em>C</em></sup></span> will be defined semantically as the weakest such fixed point, namely as the greatest fixed-point of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span>.It therefore satisfies:</p>
<p><br /><span class="math display"><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)⇔<em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>C</em><sup><em>C</em></sup>(<em>ϕ</em>))</span><br /></p>
<p>Thus, <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> states that there is some cut in the same asynchronous run <span class="math inline"><em>σ</em></span> including <span class="math inline"><em>i</em></span>’s local state, such that <span class="math inline"><em>ϕ</em></span> is true in that cut.<br />
Note that <span class="math inline"><em>ϕ</em></span> implies <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span>. But it is not the case, in general, that <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> implies <span class="math inline"><em>ϕ</em></span> or even that <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> implies <span class="math inline"><em>ϕ</em></span>. The truth of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is determined with respect to some cut <span class="math inline"><strong>c</strong>(<em>σ</em>)</span>. A process cannot distinguish which cut, of the perhaps many cuts that are in the run and consistent with its local state, satisfies <span class="math inline"><em>ϕ</em></span>; it can only know the existence of such a cut.<br />
<span><span class="math inline"> </span> <strong><em>(Global fact)</em></strong> <span>Fact <span class="math inline"><em>ϕ</em></span> is valid in system <span class="math inline"><em>Σ</em></span>, denoted by <span class="math inline"><em>Σ</em> ⊢ <em>ϕ</em></span>, if <span class="math inline"><em>ϕ</em></span> is true in all cuts of all runs of <span class="math inline"><em>Σ</em></span>. <br /><span class="math display"><em>Σ</em> ⊢ <em>ϕ</em> ⇔ (∀<em>σ</em> ∈ <em>Σ</em>)(∀<strong>c</strong>)(<strong>c</strong>(<em>a</em>)⊢<em>ϕ</em>)</span><br /></span></span></p>
<p>Fact <span class="math inline"><em>ϕ</em></span> is valid, denoted <span class="math inline">⊢<em>ϕ</em></span>, if <span class="math inline"><em>ϕ</em></span> is valid in all systems, i.e. <span class="math inline">(∀<em>Σ</em>)(<em>Σ</em> ⊢ <em>ϕ</em>)</span>.<br />
<span><span class="math inline"> </span> <strong><em>(Local fact)</em></strong> <span>A fact <span class="math inline"><em>ϕ</em></span> is local to process <span class="math inline"><em>i</em></span> in system <span class="math inline"><em>Σ</em></span> if <span class="math inline"><em>Σ</em> ⊢ (<em>ϕ</em> ⇒ <em>K</em><sub><em>i</em></sub><em>ϕ</em>)</span>.</span></span></p>
<h2 id="dominator-graph-theory">Dominator (graph theory)</h2>
<p>In a graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>, <em>r</em>)</span> a dominator is the relation between two vertices. A vertex <span class="math inline"><em>v</em></span> is dominated by another vertex <span class="math inline"><em>w</em></span>, if every path in the graph from the root <span class="math inline"><em>r</em></span> to <span class="math inline"><em>v</em></span> have to go through <span class="math inline"><em>w</em></span>. Furthermore, the immediate dominator for a vertex <span class="math inline"><em>v</em></span> is the last of <span class="math inline"><em>v</em></span>’s dominators, which every path in the graph have to go through to reach <span class="math inline"><em>v</em></span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Pseudo top)</em></strong> <span>A pseudo vertex, called top, is the parent of all top event blocks. Denoted by <span class="math inline">⊤</span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Pseudo bottom)</em></strong> <span>A pseudo vertex, called bottom, is the child of all leaf event blocks. Denoted by <span class="math inline">⊥</span>.</span></span> With the pseudo vertices, we have <span class="math inline">⊥</span> happened-before all event blocks. Also all event blocks happened-before <span class="math inline">⊤</span>. That is, for all event <span class="math inline"><em>v</em><sub><em>i</em></sub></span>, <span class="math inline">⊥ → <em>v</em><sub><em>i</em></sub></span> and <span class="math inline"><em>v</em><sub><em>i</em></sub> → ⊤</span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Dom)</em></strong> <span>An event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if every path from <span class="math inline">⊤</span> to <span class="math inline"><em>v</em><sub><em>x</em></sub></span> must go through <span class="math inline"><em>v</em><sub><em>d</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub> ≫ <em>v</em><sub><em>x</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Strict dom)</em></strong> <span>An event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> strictly dominates an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if <span class="math inline"><em>v</em><sub><em>d</em></sub> ≫ <em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>d</em></sub></span> does not equal <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>s</em></sup><em>v</em><sub><em>x</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Domfront)</em></strong> <span>A vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> is said “domfront” a vertex <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates an immediate predecessor of <span class="math inline"><em>v</em><sub><em>x</em></sub></span>, but <span class="math inline"><em>v</em><sub><em>d</em></sub></span> does not strictly dominate <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Dominance frontier)</em></strong> <span>The dominance frontier of a vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> is the set of all nodes <span class="math inline"><em>v</em><sub><em>x</em></sub></span> such that <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>D</em><em>F</em>(<em>v</em><sub><em>d</em></sub>)</span>.</span></span></p>
<p>From the above definitions of domfront and dominance frontier, the following holds. If <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>, then <span class="math inline"><em>v</em><sub><em>x</em></sub> ∈ <em>D</em><em>F</em>(<em>v</em><sub><em>d</em></sub>)</span>.</p>
<h2 id="opera-chain-dag">OPERA chain (DAG)</h2>
<p>The core idea of the Lachesis protocol is to use a DAG-based structure, called the OPERA chain for our consensus algorithm. In the Lachesis protocol, a (participant) node is a server (machine) of the distributed system. Each node can create messages, send messages to, and receive messages from, other nodes. The communication between nodes is asynchronous.</p>
<p>Let <span class="math inline"><em>n</em></span> be the number of participant nodes. For consensus, the algorithm examines whether an event block is <em>dominated</em> by <span class="math inline">2<em>n</em>/3</span> nodes, where <span class="math inline"><em>n</em></span> is the number of all nodes. The Happen-before relation of event blocks with <span class="math inline">2<em>n</em>/3</span> nodes means that more than two-thirds of all nodes in the OPERA chain know the event block.</p>
<p>The OPERA chain (DAG) is the local view of the DAG held by each node, this local view is used to identify topological ordering, select Clotho, and create time consensus through Atropos selection. OPERA chain is a DAG graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> consisting of <span class="math inline"><em>V</em></span> vertices and <span class="math inline"><em>E</em></span> edges. Each vertex <span class="math inline"><em>v</em><sub><em>i</em></sub> ∈ <em>V</em></span> is an event block. An edge <span class="math inline">(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)∈<em>E</em></span> refers to a hashing reference from <span class="math inline"><em>v</em><sub><em>i</em></sub></span> to <span class="math inline"><em>v</em><sub><em>j</em></sub></span>; that is, <span class="math inline"><em>v</em><sub><em>i</em></sub> ↪ <em>v</em><sub><em>j</em></sub></span>.</p>
<p><span><span class="math inline"> </span> <strong><em>(Leaf)</em></strong> <span>The first created event block of a node is called a leaf event block.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Root)</em></strong> <span>The leaf event block of a node is a root. When an event block <span class="math inline"><em>v</em></span> can reach more than <span class="math inline">2<em>n</em>/3</span> of the roots in the previous frames, <span class="math inline"><em>v</em></span> becomes a root.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Root set)</em></strong> <span>The set of all first event blocks (leaf events) of all nodes form the first root set <span class="math inline"><em>R</em><sub>1</sub></span> (<span class="math inline">|<em>R</em><sub>1</sub>|</span> = <span class="math inline"><em>n</em></span>). The root set <span class="math inline"><em>R</em><sub><em>k</em></sub></span> consists of all roots <span class="math inline"><em>r</em><sub><em>i</em></sub></span> such that <span class="math inline"><em>r</em><sub><em>i</em></sub></span> <span class="math inline">∉</span> <span class="math inline"><em>R</em><sub><em>i</em></sub></span>, <span class="math inline">∀</span> <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1) and <span class="math inline"><em>r</em><sub><em>i</em></sub></span> can reach more than 2n/3 other roots in the current frame, <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1).</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Frame)</em></strong> <span>Frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> is a natural number that separates Root sets. The root set at frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> is denoted by <span class="math inline"><em>R</em><sub><em>i</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Consistent chains)</em></strong> <span>OPERA chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are consistent if for any event <span class="math inline"><em>v</em></span> contained in both chains, <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]=<em>G</em><sub>2</sub>[<em>v</em>]</span>. Denoted by <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>.</span></span></p>
<p>When two consistent chains contain the same event <span class="math inline"><em>v</em></span>, both chains contain the same set of ancestors for <span class="math inline"><em>v</em></span>, with the same reference and self-ref edges between those ancestors.</p>
<p>If two nodes have OPERA chains containing event <span class="math inline"><em>v</em></span>, then they have the same <span class="math inline"><em>k</em></span> hashes contained within <span class="math inline"><em>v</em></span>. A node will not accept an event during a sync unless that node already has <span class="math inline"><em>k</em></span> references for that event, so both OPERA chains must contain <span class="math inline"><em>k</em></span> references for <span class="math inline"><em>v</em></span>. The cryptographic hashes are assumed to be secure, therefore the references must be the same. By induction, all ancestors of <span class="math inline"><em>v</em></span> must be the same. Therefore, the two OPERA chains are consistent.<br />
<span><span class="math inline"> </span> <strong><em>(Creator)</em></strong> <span>If a node <span class="math inline"><em>n</em><sub><em>x</em></sub></span> creates an event block <span class="math inline"><em>v</em></span>, then the creator of <span class="math inline"><em>v</em></span>, denoted by <span class="math inline"><em>c</em><em>r</em>(<em>v</em>)</span>, is <span class="math inline"><em>n</em><sub><em>x</em></sub></span>.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Consistent chain)</em></strong> <span>A global consistent chain <span class="math inline"><em>G</em><sup><em>C</em></sup></span> is a chain if <span class="math inline"><em>G</em><sup><em>C</em></sup> ∼ <em>G</em><sub><em>i</em></sub></span> for all <span class="math inline"><em>G</em><sub><em>i</em></sub></span>.</span></span></p>
<p>We denote <span class="math inline"><em>G</em> ⊑ <em>G</em>′</span> to stand for <span class="math inline"><em>G</em></span> is a subgraph of <span class="math inline"><em>G</em>′</span>. Some properties of <span class="math inline"><em>G</em><sup><em>C</em></sup></span> are given as follows:</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">∀<em>G</em><sub><em>i</em></sub></span> (<span class="math inline"><em>G</em><sup><em>C</em></sup> ⊑ <em>G</em><sub><em>i</em></sub></span>).</p></li>
<li><p><span class="math inline">∀<em>v</em> ∈ <em>G</em><sup><em>C</em></sup></span> <span class="math inline">∀<em>G</em><sub><em>i</em></sub></span> (<span class="math inline"><em>G</em><sup><em>C</em></sup>[<em>v</em>]⊑<em>G</em><sub><em>i</em></sub>[<em>v</em>]</span>).</p></li>
<li><p>(<span class="math inline">∀<em>v</em><sub><em>c</em></sub> ∈ <em>G</em><sup><em>C</em></sup></span>) (<span class="math inline">∀<em>v</em><sub><em>p</em></sub> ∈ <em>G</em><sub><em>i</em></sub></span>) ((<span class="math inline"><em>v</em><sub><em>p</em></sub> → <em>v</em><sub><em>c</em></sub>)⇒<em>v</em><sub><em>p</em></sub> ∈ <em>G</em><sup><em>C</em></sup></span>).</p></li>
</ol>
<p><span><span class="math inline"> </span> <strong><em>(Consistent root)</em></strong> <span>Two chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are root consistent, if for every <span class="math inline"><em>v</em></span> contained in both chains, <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub>1</sub></span>, then <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub>2</sub></span>.</span></span></p>
<p>By consistent chains, if <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span> and <span class="math inline"><em>v</em></span> belongs to both chains, then <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]</span> = <span class="math inline"><em>G</em><sub>2</sub>[<em>v</em>]</span>. We can prove the proposition by induction. For <span class="math inline"><em>j</em></span> = 0, the first root set is the same in both <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span>. Hence, it holds for <span class="math inline"><em>j</em></span> = 0. Suppose that the proposition holds for every <span class="math inline"><em>j</em></span> from 0 to <span class="math inline"><em>k</em></span>. We prove that it also holds for <span class="math inline"><em>j</em></span>= <span class="math inline"><em>k</em></span> + 1. Suppose that <span class="math inline"><em>v</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em> + 1</sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span>. Then there exists a set <span class="math inline"><em>S</em></span> reaching 2/3 of members in <span class="math inline"><em>G</em><sub>1</sub></span> of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> such that <span class="math inline">∀<em>u</em> ∈ <em>S</em></span> (<span class="math inline"><em>u</em> → <em>v</em></span>). As <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, and <span class="math inline"><em>v</em></span> in <span class="math inline"><em>G</em><sub>2</sub></span>, then <span class="math inline">∀<em>u</em> ∈ <em>S</em></span> (<span class="math inline"><em>u</em> ∈ <em>G</em><sub>2</sub></span>). Since the proposition holds for <span class="math inline"><em>j</em></span>=<span class="math inline"><em>k</em></span>, As <span class="math inline"><em>u</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span>, <span class="math inline"><em>u</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>. Hence, the set <span class="math inline"><em>S</em></span> of 2/3 members <span class="math inline"><em>u</em></span> happens before <span class="math inline"><em>v</em></span> in <span class="math inline"><em>G</em><sub>2</sub></span>. So <span class="math inline"><em>v</em></span> belongs to <span class="math inline"><em>f</em><sub><em>k</em> + 1</sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>.</p>
<p>Thus, all nodes have the same consistent root sets, which are the root sets in <span class="math inline"><em>G</em><sup><em>C</em></sup></span>. Frame numbers are consistent for all nodes.<br />
<span><span class="math inline"> </span> <strong><em>(Flag table)</em></strong> <span>A flag table stores reachability from an event block to another root. The sum of all reachabilities, namely all values in flag table, indicates the number of reachabilities from an event block to other roots.</span></span></p>
<p><span><span class="math inline"> </span> <strong><em>(Consistent flag table)</em></strong> <span>For any top event <span class="math inline"><em>v</em></span> in both OPERA chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span>, and <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, then the flag tables of <span class="math inline"><em>v</em></span> are consistent if they are the same in both chains.</span></span></p>
<p>From the above, the root sets of <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are consistent. If <span class="math inline"><em>v</em></span> contained in <span class="math inline"><em>G</em><sub>1</sub></span>, and <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub>1</sub></span>, then <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub><em>i</em></sub></span>. Since <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]=<em>G</em><sub>2</sub>[<em>v</em>]</span>. The reference event blocks of <span class="math inline"><em>v</em></span> are the same in both chains. Thus the flag tables of <span class="math inline"><em>v</em></span> of both chains are the same.<br />
<span><span class="math inline"> </span> <strong><em>(Clotho)</em></strong> <span>A root <span class="math inline"><em>r</em><sub><em>k</em></sub></span> in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 3</sub></span> can nominate a root <span class="math inline"><em>r</em><sub><em>a</em></sub></span> as Clotho if more than 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 1</sub></span> dominate <span class="math inline"><em>r</em><sub><em>a</em></sub></span> and <span class="math inline"><em>r</em><sub><em>k</em></sub></span> dominates the roots in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 1</sub></span>.</span></span></p>
<p>Each node nominates a root into Clotho via the flag table. If all nodes have an OPERA chain with same shape, the values in flag table will be equal to each other in OPERA chain. Thus, all nodes nominate the same root into Clotho since the OPERA chain of all nodes has same shape.</p>
<p><span><span class="math inline"> </span> <strong><em>(Atropos)</em></strong> <span>An Atropos is assigned consensus time through the Lachesis consensus algorithm and is utilized for determining the order between event blocks. Atropos blocks form a Main-chain, which allows time consensus ordering and responses to attacks.</span></span></p>
<p>For any root set <span class="math inline"><em>R</em></span> in the frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span>, the time consensus algorithm checks whether more than 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> − 1</sub></span> selects the same value. However, each node selects one of the values collected from the root set in the previous frame by the time consensus algorithm and Reselection process. Based on the Reselection process, the time consensus algorithm can reach agreement. However, there is a possibility that consensus time candidate does not reach agreement <span class="citation"></span>. To solve this problem, time consensus algorithm includes minimal selection frame per next <span class="math inline"><em>h</em></span> frame. In minimal value selection algorithm, each root selects minimum value among values collected from previous root set. Thus, the consensus time reaches consensus by time consensus algorithm.</p>
<p><span><span class="math inline"> </span> <strong><em>(Main-chain (Blockchain))</em></strong> <span>For faster consensus, <em>Main-chain</em> is a special sub-graph of the OPERA chain (DAG).</span></span></p>
<p>The Main chain — a core subgraph of OPERA chain, plays the important role of ordering the event blocks. The Main chain stores shortcuts to connect between the Atropos. After the topological ordering is computed over all event blocks through the Lachesis protocol, Atropos blocks are determined and form the Main chain. To improve path searching, we use a flag table — a local hash table structure as a cache that is used to quickly determine the closest root to a event block.</p>
<p>In the OPERA chain, an event block is called a <em>root</em> if the event block is linked to more than two-thirds of previous roots. A leaf vertex is also a root itself. With root event blocks, we can keep track of “vital” blocks that <span class="math inline">2<em>n</em>/3</span> of the network agree on.</p>
<p>[H] <embed src="Mainchain.pdf" title="fig:" height="302" /></p>
<p>Figure [fig:mainchain] shows an example of the Main chain composed of Atropos event blocks. In particular, the Main chain consists of Atropos blocks that are derived from root blocks and so are agreed by <span class="math inline">2<em>n</em>/3</span> of the network nodes. Thus, this guarantees that at least <span class="math inline">2<em>n</em>/3</span> of nodes have come to consensus on this Main chain.</p>
<p>Each participant node has a copy of the Main chain and can search consensus position of its own event blocks. Each event block can compute its own consensus position by checking the nearest Atropos event block. Assigning and searching consensus position are introduced in the consensus time selection section.</p>
<p>The Main chain provides quick access to the previous transaction history to efficiently process new incoming event blocks. From the Main chain, information about unknown participants or attackers can be easily viewed. The Main chain can be used efficiently in transaction information management by providing quick access to new event blocks that have been agreed on by the majority of nodes. In short, the Main-chain gives the following advantages:</p>
<p>- All event blocks or nodes do not need to store all information. It is efficient for data management.</p>
<p>- Access to previous information is efficient and fast.</p>
<p>Based on these advantages, OPERA chain can respond strongly to efficient transaction treatment and attacks through its Main-chain.</p>
<h1 id="se:lca">Lachesis Protocol</h1>
<p><em>loop</em>: A, B = <span class="math inline"><em>k</em></span>-node Selection algorithm() Request sync to node A and B Sync all known events by Lachesis protocol Event block creation (optional) Broadcast out the message Root selection Clotho selection Atropos time consensus <em>loop</em>: Request sync from a node Sync all known events by Lachesis protocol</p>
<p>Algorithm [al:main] shows the pseudo algorithm for the Lachesis core procedure. The algorithm consists of two parts and runs them in parallel.</p>
<p>- In part one, each node requests synchronization and creates event blocks. In line 3, a node runs the Node Selection Algorithm. The Node Selection Algorithm returns the <span class="math inline"><em>k</em></span> IDs of other nodes to communicate with. In line 4 and 5, the node synchronizes the OPERA chain (DAG) with the other nodes. Line 6 runs the Event block creation, at which step the node creates an event block and checks whether it is a root. The node then broadcasts the created event block to all other known nodes in line 7. The step in this line is optional. In line 8 and 9, Clotho selection and Atropos time consensus algorithms are invoked. The algorithms determines whether the specified root can be a Clotho, assign the consensus time, and then confirm the Atropos.</p>
<p>- The second part is to respond to synchronization requests. In line 10 and 11, the node receives a synchronization request and then sends its response about the OPERA chain.</p>
<h2 id="peer-selection-algorithm">Peer selection algorithm</h2>
<p>In order to create an event block, a node needs to select <span class="math inline"><em>k</em></span> other nodes. Lachesis protocols does not depend on how peer nodes are selected. One simple approach can use a random selection from the pool of <span class="math inline"><em>n</em></span> nodes. The other approach is to define some criteria or cost function to select other peers of a node.</p>
<p>Within distributed system, a node can select other nodes with low communication costs, low network latency, high bandwidth, high successful transaction throughputs.</p>
<h2 id="dynamic-participants">Dynamic participants</h2>
<p>Our Lachesis protocol allows an arbitrary number of participants to dynamically join the system. The OPERA chain (DAG) can still operate with new participants. Computation on flag tables is set based and independent of which and how many participants have joined the system. Algorithms for selection of Roots, Clothos and Atroposes are flexible enough and not dependence on a fixed number of participants.</p>
<h2 id="peer-synchronization">Peer synchronization</h2>
<p>We describe an algorithm that synchronizes events between the nodes.</p>
<p>Node <span class="math inline"><em>n</em><sub>1</sub></span> selects random peer to synchronize with <span class="math inline"><em>n</em><sub>1</sub></span> gets local known events (map[int]int) <span class="math inline"><em>n</em><sub>1</sub></span> sends RPC request Sync request to peer <span class="math inline"><em>n</em><sub>2</sub></span> receives RPC requestSync request <span class="math inline"><em>n</em><sub>2</sub></span> does an EventDiff check on the known map (map[int]int)</p>
<p><span class="math inline"><em>n</em><sub>2</sub></span> returns unknown events, and map[int]int of known events to <span class="math inline"><em>n</em><sub>1</sub></span></p>
<p>The algorithm assumes that a node always needs the events in topological ordering (specifically in reference to the lamport timestamps), an alternative would be to use an inverse bloom lookup table (IBLT) for completely potential randomized events.<br />
Alternatively, one can simply use a fixed incrementing index to keep track of the top event for each node.<br />
</p>
<h2 id="node-structure">Node Structure</h2>
<p>This section gives an overview of the node structure in Lachesis.</p>
<p>Each node has a height vector, in-degree vector, flag table, frames, clotho check list, max-min value, main-chain (blockchain), and their own local view of the OPERA chain (DAG). The height vector is the number of event blocks created by the <span class="math inline"><em>i</em><sup><em>t</em><em>h</em></sup></span> node. The in-degree vector refers to the number of edges from other event blocks created by other nodes to the top event block of this node. The top event block indicates the most recently created event block by this node. The flag table is a <span class="math inline"><em>n</em><em>x</em><em>k</em></span> matrix, where n is the number of nodes and k is the number of roots that an event block can reach. If an event block <span class="math inline"><em>e</em></span> created by <span class="math inline"><em>i</em><sup><em>t</em><em>h</em></sup></span> node can reach <span class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span> root, then the flag table stores the hash value of the <span class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span> root. Each node maintains the flag table of each top event block.</p>
<p>Frames store the root set in each frame. Clotho check list has two types of check points; Clotho candidate (<span class="math inline"><em>C</em><em>C</em></span>) and Clotho (<span class="math inline"><em>C</em></span>). If a root in a frame is a <span class="math inline"><em>C</em><em>C</em></span>, a node check the <span class="math inline"><em>C</em><em>C</em></span> part and if a root becomes Clotho, a node check <span class="math inline"><em>C</em></span> part. Max-min value is timestamp that addresses for Atropos selection. The Main-chain is a data structure storing hash values of the Atropos blocks.</p>
<div class="figure">
<embed src="Node_structure.pdf" />
<p class="caption">An Example of Node Structure<span data-label="fig:node"></span></p>
</div>
<p>Figure [fig:node] shows an example of the node structure component of a node <span class="math inline"><em>A</em></span>. In the figure, each value excluding self height in the height vector is 1 since the initial state is shared to all nodes. In the in-degree vector, node <span class="math inline"><em>A</em></span> stores the number of edges from other event blocks created by other nodes to the top event block. The in-degrees of node <span class="math inline"><em>A</em></span>, <span class="math inline"><em>B</em></span>, and <span class="math inline"><em>C</em></span> are 1. In flag table, node <span class="math inline"><em>A</em></span> knows other two root hashes since the top event block can reach those two roots. Node <span class="math inline"><em>A</em></span> also knows that other nodes know their own roots. In the example situation there is no clotho candidate and Clotho, and thus clotho check list is empty. The main-chain and max-min value are empty for the same reason as clotho check list.</p>
<h2 id="peer-selection-algorithm-via-cost-function">Peer selection algorithm via Cost function</h2>
<p>We define three versions of the Cost Function (<span class="math inline"><em>C</em><sub><em>F</em></sub></span>). Version one is focused around updated information share and is discussed below. The other two versions are focused on root creation and consensus facilitation, these will be discussed in a following paper.</p>
<p>We define a Cost Function (<span class="math inline"><em>C</em><sub><em>F</em></sub></span>) for preventing the creation of lazy nodes. A lazy node is a node that has a lower work portion in the OPERA chain (has created fewer event blocks). When a node creates an event block, the node selects other nodes with low value outputs from the cost function and refers to the top event blocks of the reference nodes. An equation ([eq1]) of <span class="math inline"><em>C</em><sub><em>F</em></sub></span> is as follows,</p>
<p><br /><span class="math display"><em>C</em><sub><em>F</em></sub> = <em>I</em>/<em>H</em></span><br /></p>
<p>where <span class="math inline"><em>I</em></span> and <span class="math inline"><em>H</em></span> denote values of in-degree vector and height vector respectively. If the number of nodes with the lowest <span class="math inline"><em>C</em><sub><em>F</em></sub></span> is more than <span class="math inline"><em>k</em></span>, one of the nodes is selected at random. The reason for selecting high <span class="math inline"><em>H</em></span> is that we can expect a high possibility to create a root because the high <span class="math inline"><em>H</em></span> indicates that the communication frequency of the node had more opportunities than others with low <span class="math inline"><em>H</em></span>. Otherwise, the nodes that have high <span class="math inline"><em>C</em><sub><em>F</em></sub></span> (the case of <span class="math inline"><em>I</em></span> <span class="math inline">&gt;</span> <span class="math inline"><em>H</em></span>) have generated fewer event blocks than the nodes that have low <span class="math inline"><em>C</em><sub><em>F</em></sub></span>..</p>
<div class="figure">
<embed src="costfunction_1.pdf" />
<p class="caption">An Example of Cost Function 1<span data-label="fig:costfunction_1"></span></p>
</div>
<p>Figure [fig:costfunction_1] shows an example of the node selection based on the cost function after the creation of leaf events by all nodes. In this example, there are five nodes and each node created leaf events. All nodes know other leaf events. Node <span class="math inline"><em>A</em></span> creates an event block <span class="math inline"><em>v</em><sub>1</sub></span> and <span class="math inline"><em>A</em></span> calculates the cost functions. Step 2 in Figure [fig:costfunction_1] shows the results of cost functions based on the height and in-degree vectors of node <span class="math inline"><em>A</em></span>. In the initial step, each value in the vectors are same because all nodes have only leaf events. Node <span class="math inline"><em>A</em></span> randomly selects <span class="math inline"><em>k</em></span> nodes and connects <span class="math inline"><em>v</em><sub>1</sub></span> to the leaf events of selected nodes. In this example, we set <span class="math inline"><em>k</em></span>=3 and assume that node <span class="math inline"><em>A</em></span> selects node <span class="math inline"><em>B</em></span> and <span class="math inline"><em>C</em></span>.</p>
<div class="figure">
<embed src="costfunction_2.pdf" />
<p class="caption">An Example of Cost Function 2<span data-label="fig:costfunction_2"></span></p>
</div>
<p>Figure [fig:costfunction_2] shows an example of the node selection after a few steps of the simulation in Figure [fig:costfunction_1]. In Figure [fig:costfunction_2], the recent event block is <span class="math inline"><em>v</em><sub>5</sub></span> created by node <span class="math inline"><em>A</em></span>. Node <span class="math inline"><em>A</em></span> calculates the cost function and selects the other two nodes that have the lowest results of the cost function. In this example, node <span class="math inline"><em>B</em></span> has 0.5 as the result and other nodes have the same values. Because of this, node <span class="math inline"><em>A</em></span> first selects node <span class="math inline"><em>B</em></span> and randomly selects other nodes among nodes <span class="math inline"><em>C</em></span>, <span class="math inline"><em>D</em></span>, and <span class="math inline"><em>E</em></span>.</p>
<p>The height of node <span class="math inline"><em>D</em></span> in the example is 2 (leaf event and event block <span class="math inline"><em>v</em><sub>4</sub></span>). On the other hand, the height of node <span class="math inline"><em>D</em></span> in node structure of <span class="math inline"><em>A</em></span> is 1. Node <span class="math inline"><em>A</em></span> is still not aware of the presence of the event block <span class="math inline"><em>v</em><sub>4</sub></span>. It means that there is no path from the event blocks created by node <span class="math inline"><em>A</em></span> to the event block <span class="math inline"><em>v</em><sub>4</sub></span>. Thus, node <span class="math inline"><em>A</em></span> has 1 as the height of node <span class="math inline"><em>D</em></span>.</p>
<p><strong>Input:</strong> Height Vector <span class="math inline"><em>H</em></span>, In-degree Vector <span class="math inline"><em>I</em></span> <strong>Output:</strong> reference node <span class="math inline"><em>r</em><em>e</em><em>f</em></span> min_cost <span class="math inline">←</span> <span class="math inline"><em>I</em><em>N</em><em>F</em></span> <span class="math inline"><em>s</em><sub><em>r</em><em>e</em><em>f</em></sub></span> <span class="math inline">←</span> None <span class="math inline"><em>c</em><sub><em>f</em></sub></span> <span class="math inline">←</span> <span class="math inline">$\frac{I_k}{H_k}$</span> min_cost <span class="math inline">←</span> <span class="math inline"><em>c</em><sub><em>f</em></sub></span> <span class="math inline"><em>s</em><sub><em>r</em><em>e</em><em>f</em></sub></span> <span class="math inline">←</span> <span>k</span> <span class="math inline"><em>s</em><sub><em>r</em><em>e</em><em>f</em></sub></span> <span class="math inline">←</span> <span class="math inline"><em>s</em><sub><em>r</em><em>e</em><em>f</em></sub></span> <span class="math inline">∪</span> <span class="math inline"><em>k</em></span> <span class="math inline"><em>r</em><em>e</em><em>f</em></span> <span class="math inline">←</span> random select in <span class="math inline"><em>s</em><sub><em>r</em><em>e</em><em>f</em></sub></span></p>
<p>Algorithm [al:ns] shows the selecting algorithm for selecting reference nodes. The algorithm operates for each node to select a communication partner from other nodes. Line 4 and 5 set min_cost and <span class="math inline"><em>S</em><sub><em>r</em><em>e</em><em>f</em></sub></span> to initial state. Line 7 calculates the cost function <span class="math inline"><em>c</em><sub><em>f</em></sub></span> for each node. In line 8, 9, and 10, we find the minimum value of the cost function and set min_cost and <span class="math inline"><em>S</em><sub><em>r</em><em>e</em><em>f</em></sub></span> to <span class="math inline"><em>c</em><sub><em>f</em></sub></span> and the ID of each node respectively. Line 11 and 12 append the ID of each node to <span class="math inline"><em>S</em><sub><em>r</em><em>e</em><em>f</em></sub></span> if min_cost equals <span class="math inline"><em>c</em><sub><em>f</em></sub></span>. Finally, line 13 selects randomly <span class="math inline"><em>k</em></span> node IDs from <span class="math inline"><em>S</em><sub><em>r</em><em>e</em><em>f</em></sub></span> as communication partners. The time complexity of Algorithm 2 is <span class="math inline"><em>O</em>(<em>n</em>)</span>, where <span class="math inline"><em>n</em></span> is the number of nodes.</p>
<p>After the reference node is selected, each node communicates and shares information of all event blocks known by them. A node creates an event block by referring to the top event block of the reference node. The Lachesis protocol works and communicates asynchronously. This allows a node to create an event block asynchronously even when another node creates an event block. The communication between nodes does not allow simultaneous communication with the same node.</p>
<div class="figure">
<embed src="node_selection.pdf" height="264" />
<p class="caption">An Example of Node Selection<span data-label="fig:node_selection"></span></p>
</div>
<p>Figure [fig:node_selection] shows an example of the node selection in Lachesis protocol. In this example, there are five nodes (<span class="math inline"><em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>,</span> and <span class="math inline"><em>E</em></span>) and each node generates the first event blocks, called leaf events. All nodes share other leaf events with each other. In the first step, node <span class="math inline"><em>A</em></span> generates new event block <span class="math inline"><em>a</em><sub>1</sub></span>. Then node <span class="math inline"><em>A</em></span> calculates the cost function to connect other nodes. In this initial situation, all nodes have one event block called leaf event, thus the height vector and the in-degree vector in node <span class="math inline"><em>A</em></span> has same values. In other words, the heights of each node are 1 and in-degrees are 0. Node <span class="math inline"><em>A</em></span> randomly select the other two nodes and connects <span class="math inline"><em>a</em><sub>1</sub></span> to the top two event blocks from the other two nodes. Step 2 shows the situation after connections. In this example, node <span class="math inline"><em>A</em></span> select node <span class="math inline"><em>B</em></span> and <span class="math inline"><em>C</em></span> to connect <span class="math inline"><em>a</em><sub>1</sub></span> and the event block <span class="math inline"><em>a</em><sub>1</sub></span> is connected to the top event blocks of node <span class="math inline"><em>B</em></span> and <span class="math inline"><em>C</em></span>. Node <span class="math inline"><em>A</em></span> only knows the situation of the step 2.</p>
<p>After that, in the example, node <span class="math inline"><em>B</em></span> generates a new event block <span class="math inline"><em>b</em><sub>1</sub></span> and also calculates the cost function. <span class="math inline"><em>B</em></span> randomly select the other two nodes; <span class="math inline"><em>A</em></span>, and <span class="math inline"><em>D</em></span>, since <span class="math inline"><em>B</em></span> only has information of the leaf events. Node <span class="math inline"><em>B</em></span> requests to <span class="math inline"><em>A</em></span> and <span class="math inline"><em>D</em></span> to connect <span class="math inline"><em>b</em><sub>1</sub></span>, then nodes <span class="math inline"><em>A</em></span> and <span class="math inline"><em>D</em></span> send information for their top event blocks to node <span class="math inline"><em>B</em></span> as response. The top event block of node <span class="math inline"><em>A</em></span> is <span class="math inline"><em>a</em><sub>1</sub></span> and node <span class="math inline"><em>D</em></span> is the leaf event. The event block <span class="math inline"><em>b</em><sub>1</sub></span> is connected to <span class="math inline"><em>a</em><sub>1</sub></span> and leaf event from node <span class="math inline"><em>D</em></span>. Step 4 shows these connections.</p>
<h2 id="event-block-creation">Event block creation</h2>
<p>In the Lachesis protocol, every node can create an event block. Each event block refers to other <span class="math inline"><em>k</em></span> event blocks using their hash values. In the Lachesis protocol, a new event block refers to <span class="math inline"><em>k</em></span>-neighbor event blocks under the following conditions:</p>
<ol>
<li><p>Each of the <span class="math inline"><em>k</em></span> reference event blocks is the top event blocks of its own node.</p></li>
<li><p>One reference should be made to a self-ref that references to an event block of the same node.</p></li>
<li><p>The other <span class="math inline"><em>k</em></span>-1 reference refers to the other <span class="math inline"><em>k</em></span>-1 top event nodes on other nodes.</p></li>
</ol>
<div class="figure">
<embed src="Ex_eventblock.pdf" style="width:100.0%" />
<p class="caption">An Example of Event Block Creation with Flag Table<span data-label="fig:ex_ebc"></span></p>
</div>
<p>Figure [fig:ex_ebc] shows the example of an event block creation with a flag table. In this example the recent created event block is <span class="math inline"><em>b</em><sub>1</sub></span> by node <span class="math inline"><em>B</em></span>. The figure shows the node structure of node <span class="math inline"><em>B</em></span>. We omit the other information such as height and in-degree vectors since we only focus on the change of the flag table with the event block creation in this example. The flag table of <span class="math inline"><em>b</em><sub>1</sub></span> in Figure [fig:ex_ebc] is updated with the information of the previous connected event blocks <span class="math inline"><em>a</em><sub>1</sub></span>, <span class="math inline"><em>b</em><sub>0</sub></span>, and <span class="math inline"><em>c</em><sub>1</sub></span>. Thus, the set of the flag table is the results of OR operation among the three root sets for <span class="math inline"><em>a</em>1</span> (<span class="math inline"><em>a</em><sub>0</sub></span>, <span class="math inline"><em>b</em><sub>0</sub></span>, and <span class="math inline"><em>c</em><sub>0</sub></span>), <span class="math inline"><em>b</em><sub>0</sub></span> (<span class="math inline"><em>b</em><sub>0</sub></span>), and <span class="math inline"><em>c</em><sub>1</sub></span> (<span class="math inline"><em>b</em><sub>0</sub></span>, <span class="math inline"><em>c</em><sub>0</sub></span>, and <span class="math inline"><em>d</em><sub>0</sub></span>).</p>
<div class="figure">
<embed src="sync.pdf" height="226" />
<p class="caption">An Example of Communication Process<span data-label="fig:communication process"></span></p>
</div>
<p>Figure [fig:communication process], shows the communication process is divided into five steps for two nodes to create an event block. Simply, a node <span class="math inline"><em>A</em></span> requests to <span class="math inline"><em>B</em></span>. then, <span class="math inline"><em>B</em></span> responds to <span class="math inline"><em>A</em></span> directly.</p>
<h2 id="topological-ordering-of-events-using-lamport-timestamps">Topological ordering of events using Lamport timestamps</h2>
<p>Every node has a physical clock and it needs physical time to create an event block. However, for consensus, Lachesis protocols relies on a logical clock for each node. For the purpose, we use <em>“Lamport timestamps”</em> <span class="citation"></span> to determine the time ordering between event blocks in a asynchronous distributed system.</p>
<div class="figure">
<embed src="Lamport_timestamps.pdf" style="width:70.0%" />
<p class="caption">An example of Lamport timestamps<span data-label="fig:Lamport"></span></p>
</div>
<p>The Lamport timestamps algorithm is as follows:</p>
<ol>
<li><p>Each node increments its count value before creating an event block.</p></li>
<li><p>When sending a message include its count value, receiver should consider which sender’s message is received and increments its count value.</p></li>
<li><p>If current counter is less than or equal to the received count value from another node, then the count value of the recipient is updated.</p></li>
<li><p>If current counter is greater than the received count value from another node, then the current count value is updated.</p></li>
</ol>
<p>We use the Lamport’s algorithm to enforce a topological ordering of event blocks and use it in the Atropos selection algorithm.</p>
<p>Since an event block is created based on logical time, the sequence between each event blocks is immediately determined. Because the Lamport timestamps algorithm gives a partial order of all events, the whole time ordering process can be used for Byzantine fault tolerance.</p>
<h2 id="domination-relation">Domination Relation</h2>
<p>Here, we introduce a new idea that extends the concept of domination.<br />
For a vertex <span class="math inline"><em>v</em></span> in a DAG <span class="math inline"><em>G</em></span>, let <span class="math inline"><em>G</em>[<em>v</em>]=(<em>V</em><sub><em>v</em></sub>, <em>E</em><sub><em>v</em></sub>)</span> denote an induced-subgraph of <span class="math inline"><em>G</em></span> such that <span class="math inline"><em>V</em><sub><em>v</em></sub></span> consists of all ancestors of <span class="math inline"><em>v</em></span> including <span class="math inline"><em>v</em></span>, and <span class="math inline"><em>E</em><sub><em>v</em></sub></span> is the induced edges of <span class="math inline"><em>V</em><sub><em>v</em></sub></span> in <span class="math inline"><em>G</em></span>.<br />
For a set <span class="math inline"><em>S</em></span> of vertices, an event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>S</em></span> if there are more than 2/3 of vertices <span class="math inline"><em>v</em><sub><em>x</em></sub></span> in <span class="math inline"><em>S</em></span> such that <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Recall that <span class="math inline"><em>R</em><sub>1</sub></span> is the set of all leaf vertices in <span class="math inline"><em>G</em></span>. The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub>0</sub></span> is the same as the set <span class="math inline"><em>R</em><sub>1</sub></span>.The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>i</em></sub></span> is defined as follows:<br />
A vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> belongs to a <span class="math inline">$\frac{2}{3}$</span>-dom set within the graph <span class="math inline"><em>G</em>[<em>v</em><sub><em>d</em></sub>]</span>, if <span class="math inline"><em>v</em><sub><em>d</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>R</em><sub>1</sub></span>. The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>k</em></sub></span> consists of all roots <span class="math inline"><em>d</em><sub><em>i</em></sub></span> such that <span class="math inline"><em>d</em><sub><em>i</em></sub></span> <span class="math inline">∉</span> <span class="math inline"><em>D</em><sub><em>i</em></sub></span>, <span class="math inline">∀</span> <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1), and <span class="math inline"><em>d</em><sub><em>i</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>D</em><sub><em>i</em> − 1</sub></span>.<br />
The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>i</em></sub></span> is the same with the root set <span class="math inline"><em>R</em><sub><em>i</em></sub></span>, for all nodes.<br />
</p>
<h2 id="examples-of-domination-relation-in-dags">Examples of domination relation in DAGs</h2>
<p>This section gives several examples of DAGs and the domination relation between their event blocks.</p>
<p>(a)<img src="domtrees" title="fig:" alt="Examples of OPERA chain and dominator tree" /><br />
(b)<img src="domtrees_add1event" title="fig:" alt="Examples of OPERA chain and dominator tree" /></p>
<p>Figure [fig:domtrees1] shows an examples of a DAG and dominator trees.</p>
<div class="figure">
<img src="domset" alt="An example of OPERA chain and its 2/3 domination graph. The \frac{2}{3}-dom sets are shown in grey." />
<p class="caption">An example of OPERA chain and its 2/3 domination graph. The <span class="math inline">$\frac{2}{3}$</span>-dom sets are shown in grey.<span data-label="fig:domset1"></span></p>
</div>
<p>Figure [fig:domset1] depicts an example of a DAG and 2/3 dom sets.</p>
<p>(a) <img src="deptrees" title="fig:" alt="An example of dependency graphs on individual nodes. From (a)-(c) there is one new event block appended. There is no fork, the simplified dependency graphs become trees." /><br />
(b) <img src="deptrees_mod_add1event" title="fig:" alt="An example of dependency graphs on individual nodes. From (a)-(c) there is one new event block appended. There is no fork, the simplified dependency graphs become trees." /><br />
(c) <img src="deptrees_mod_add2event" title="fig:" alt="An example of dependency graphs on individual nodes. From (a)-(c) there is one new event block appended. There is no fork, the simplified dependency graphs become trees." /></p>
<p>Figure [fig:deptreesmod1] shows an example an dependency graphs. On each row, the left most figure shows the latest OPERA chain. The left figures on each row depict the dependency graphs of each node, which are in their compact form. When no fork presents, each of the compact dependency graphs is a tree.</p>
<p>(a)<img src="deptrees_fork" title="fig:" alt="An example of a pair of fork events in an OPERA chain. The fork events are shown in red and green. The OPERA chains from (a) to (d) are different by adding one single event at a time." /><br />
(b)<img src="deptrees_fork_add1event" title="fig:" alt="An example of a pair of fork events in an OPERA chain. The fork events are shown in red and green. The OPERA chains from (a) to (d) are different by adding one single event at a time." /><br />
(c)<img src="deptrees_fork_add2event" title="fig:" alt="An example of a pair of fork events in an OPERA chain. The fork events are shown in red and green. The OPERA chains from (a) to (d) are different by adding one single event at a time." /></p>
<p>Figure [fig:deptreesfork1] shows an example of a pair of fork events. Each row shows an OPERA chain (left most) and the compact dependency graphs on each node (right). The fork events are shown in red and green vertices</p>
<h2 id="root-selection">Root Selection</h2>
<p>All nodes can create event blocks and an event block can be a root when satisfying specific conditions. Not all event blocks can be roots. First, the first created event blocks are themselves roots. These leaf event blocks form the first root set <span class="math inline"><em>R</em><sub><em>S</em><sub>1</sub></sub></span> of the first frame <span class="math inline"><em>f</em><sub>1</sub></span>. If there are total <span class="math inline"><em>n</em></span> nodes and these nodes create the event blocks, then the cardinality of the first root set <span class="math inline">|<em>R</em><sub><em>S</em><sub>1</sub></sub>|</span> is <span class="math inline"><em>n</em></span>. Second, if an event block <span class="math inline"><em>e</em></span> can reach at least 2n/3 roots, then <span class="math inline"><em>e</em></span> is called a root. This event <span class="math inline"><em>e</em></span> does not belong to <span class="math inline"><em>R</em><sub><em>S</em>1</sub></span>, but the next root set <span class="math inline"><em>R</em><sub><em>S</em><sub>2</sub></sub></span> of the next frame <span class="math inline"><em>f</em><sub>2</sub></span>. Thus, excluding the first root set, the range of cardinality of root set <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em></sub></sub></span> is <span class="math inline">2<em>n</em>/3 &lt; |<em>R</em><sub><em>S</em><sub><em>k</em></sub></sub>|≤<em>n</em></span>. The event blocks including <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em></sub></sub></span> before <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em> + 1</sub></sub></span> is in the frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span>. The roots in <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em> + 1</sub></sub></span> does not belong to the frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span>. Those are included in the frame <span class="math inline"><em>f</em><sub><em>k</em> + 1</sub></span> when a root belonging to <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em> + 2</sub></sub></span> occurs.</p>
<p>We introduce the use of a flag table to quickly determine whether a new event block becomes a root. Each node maintains a flag table of the top event block. Every event block that is newly created is assigned <span class="math inline"><em>k</em></span> hashes for its <span class="math inline"><em>k</em></span> referenced event blocks. We apply an <span class="math inline"><em>O</em><em>R</em></span> operation on each set in the flag table of the referenced event blocks.</p>
<p>[H] <embed src="Root_selection.pdf" title="fig:" height="226" /></p>
<p>Figure [fig:ex_ft] shows an example of how to use flag tables to determine a root. In this example, <span class="math inline"><em>b</em><sub>1</sub></span> is the most recently created event block. We apply an <span class="math inline"><em>O</em><em>R</em></span> operation on each set of the flag tables for <span class="math inline"><em>b</em><sub>1</sub></span>’s <span class="math inline"><em>k</em></span> referenced event blocks. The result is the flag table of <span class="math inline"><em>b</em><sub>1</sub></span>. If the cardinality of the root set in <span class="math inline"><em>b</em><sub>1</sub></span>’s flag table is more than <span class="math inline">2<em>n</em>/3</span>, <span class="math inline"><em>b</em><sub>1</sub></span> is a root. In this example, the cardinality of the root set in <span class="math inline"><em>b</em><sub>1</sub></span> is 4, which is greater than <span class="math inline">2<em>n</em>/3</span> (<span class="math inline"><em>n</em></span>=5). Thus, <span class="math inline"><em>b</em><sub>1</sub></span> becomes root. In this example, <span class="math inline"><em>b</em><sub>1</sub></span> is added to frame <span class="math inline"><em>f</em><sub>2</sub></span> since <span class="math inline"><em>b</em><sub>1</sub></span> becomes new root.</p>
<p>The root selection algorithm is as follows:</p>
<ol>
<li><p>The first event blocks are considered as roots.</p></li>
<li><p>When a new event block is added in the OPERA chain (DAG), we check whether the event block is a root by applying an <span class="math inline"><em>O</em><em>R</em></span> operation on each set of the flag tables connected to the new event block. If the cardinality of the root set in the flag table for the new event block is more than 2n/3, the new event block becomes a root.</p></li>
<li><p>When a new root appears on the OPERA chain, nodes update their frames. If one of the new event blocks becomes a root, all nodes that share the new event block add the hash value of the event block to their frames.</p></li>
<li><p>The new root set is created if the cardinality of the previous root set <span class="math inline"><em>R</em><sub><em>S</em><sub><em>p</em></sub></sub></span> is more than 2n/3 and the new event block can reach <span class="math inline">2<em>n</em>/3</span> roots in <span class="math inline"><em>R</em><sub><em>S</em><sub><em>p</em></sub></sub></span>.</p></li>
<li><p>When the new root set <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em> + 1</sub></sub></span> is created, the event blocks from the previous root set <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em></sub></sub></span> to before <span class="math inline"><em>R</em><sub><em>S</em><sub><em>k</em> + 1</sub></sub></span> belong to the frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span>.</p></li>
</ol>
<h2 id="clotho-selection">Clotho Selection</h2>
<p>A Clotho is a root that satisfies the Clotho creation conditions. Clotho creation conditions are that more than 2n/3 nodes know the root and a root knows this information.</p>
<p>In order for a root <span class="math inline"><em>r</em></span> in frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> to become a Clotho, <span class="math inline"><em>r</em></span> must be reached by more than n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span>. Based on the definition of the root, each root reaches more than 2n/3 roots in previous frames. If more than n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> can reach <span class="math inline"><em>r</em></span>, then <span class="math inline"><em>r</em></span> is spread to all roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span>. It means that all nodes know the existence of <span class="math inline"><em>r</em></span>. If we have any root in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 3</sub></span>, a root knows that <span class="math inline"><em>r</em></span> is spread to more than 2n/3 nodes. It satisfies Clotho creation conditions.</p>
<p>[H] <embed src="frame4.pdf" title="fig:" style="width:50.0%" /></p>
<p>In the example in Figure [fig:frame4], n is 5 and each circle indicates a root in a frame. Each arrow means one root can reach (happened-before) to the previous root. Each root has 4 or 5 arrows (out-degree) since n is 5 (more than 2n/3 <span class="math inline">≥</span> 4). <span class="math inline"><em>b</em><sub>1</sub></span> and <span class="math inline"><em>c</em><sub>2</sub></span> in frame <span class="math inline"><em>f</em><sub>2</sub></span> are roots that can reach <span class="math inline"><em>c</em><sub>0</sub></span> in frame <span class="math inline"><em>f</em><sub>1</sub></span>. <span class="math inline"><em>d</em><sub>1</sub></span> and <span class="math inline"><em>e</em><sub>1</sub></span> also can reach <span class="math inline"><em>c</em><sub>0</sub></span>, but we only marked <span class="math inline"><em>b</em><sub>1</sub></span> and <span class="math inline"><em>c</em><sub>2</sub></span> (when n is 5, more than n/3 <span class="math inline">≥</span> 2) since we show at least more than n/3 conditions in this example. And it was marked with a blue bold arrow (Namely, the roots that can reach root <span class="math inline"><em>c</em><sub>0</sub></span> have the blue bold arrow). In this situation, an event block must be able to reach <span class="math inline"><em>b</em><sub>1</sub></span> or <span class="math inline"><em>c</em><sub>2</sub></span> in order to become a root in frame <span class="math inline"><em>f</em><sub>3</sub></span> (In our example, n=5, more than n/3 <span class="math inline">≥</span> 2, and more than 2n/3 <span class="math inline">≥</span> 4. Thus, to be a root, either must be reached). All roots in frame <span class="math inline"><em>f</em><sub>3</sub></span> reach <span class="math inline"><em>c</em><sub>0</sub></span> in frame <span class="math inline"><em>f</em><sub>1</sub></span>.</p>
<p>To be a root in frame <span class="math inline"><em>f</em><sub>4</sub></span>, an event block must reach more than 2n/3 roots in frame <span class="math inline"><em>f</em><sub>3</sub></span> that can reach <span class="math inline"><em>c</em><sub>0</sub></span>. Therefore, if any of the root in frame <span class="math inline"><em>f</em><sub>4</sub></span> exists, the root must have happened-before more than 2n/3 roots in frame <span class="math inline"><em>f</em><sub>3</sub></span>. Thus, the root of <span class="math inline"><em>f</em><sub>4</sub></span> knows that <span class="math inline"><em>c</em><sub>0</sub></span> is spread over more than 2n/3 of the entire nodes. Thus, we can select <span class="math inline"><em>c</em><sub>0</sub></span> as Clotho.</p>
<div class="figure">
<embed src="Clotho_fig1.pdf" style="width:80.0%" />
<p class="caption">An Example of Clotho<span data-label="fig:Clotho"></span></p>
</div>
<p>Figure [fig:Clotho] shows an example of a Clotho. In this example, all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> have happened-before more than n/3 roots in the frame <span class="math inline"><em>f</em><sub>2</sub></span>. We can select all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> as Clotho since the recent frame is <span class="math inline"><em>f</em><sub>4</sub></span>.</p>
<p>[H]</p>
<p><strong>Input</strong>: a root <span class="math inline"><em>r</em></span> <span class="math inline"><em>c</em>.<em>i</em><em>s</em>_<em>c</em><em>l</em><em>o</em><em>t</em><em>h</em><em>o</em></span> <span class="math inline">←</span> <span class="math inline"><em>n</em><em>i</em><em>l</em></span> <span class="math inline"><em>c</em>.<em>y</em><em>e</em><em>s</em></span> <span class="math inline">←</span> 0 c.yes <span class="math inline">←</span> c.yes + 1 <span class="math inline"><em>c</em>.<em>i</em><em>s</em>_<em>c</em><em>l</em><em>o</em><em>t</em><em>h</em><em>o</em></span> <span class="math inline">←</span> <span class="math inline"><em>y</em><em>e</em><em>s</em></span></p>
<p>Algorithm [al:acs] shows the pseudo code for Clotho selection. The algorithm takes a root <span class="math inline"><em>r</em></span> as input. Line 4 and 5 set <span class="math inline"><em>c</em>.<em>i</em><em>s</em>_<em>c</em><em>l</em><em>o</em><em>t</em><em>h</em><em>o</em></span> and <span class="math inline"><em>c</em>.<em>y</em><em>e</em><em>s</em></span> to <span class="math inline"><em>n</em><em>i</em><em>l</em></span> and 0 respectively. Line 6-8 checks whether any root <span class="math inline"><em>c</em>′</span> in <span class="math inline"><em>f</em><em>r</em><em>a</em><em>m</em><em>e</em>(<em>i</em> − 3, <em>r</em>)</span> has happened-before with the 2n/3 condition <span class="math inline"><em>c</em></span> where <span class="math inline"><em>i</em></span> is the current frame. In line 9-10, if the number of roots in <span class="math inline"><em>f</em><em>r</em><em>a</em><em>m</em><em>e</em>(<em>i</em> − 2, <em>r</em>)</span> which happened-before <span class="math inline"><em>c</em></span> is more than <span class="math inline">2<em>n</em>/3</span>, the root <span class="math inline"><em>c</em></span> is set as a Clotho. The time complexity of Algorithm 3 is <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>, where <span class="math inline"><em>n</em></span> is the number of nodes.</p>
<div class="figure">
<embed src="Clotho_fig2.pdf" />
<p class="caption">The node of <em>A</em> when Clotho is selected<span data-label="fig:ClothoNodeA"></span></p>
</div>
<p>Figure [fig:ClothoNodeA] shows the state of node <em>A</em> when a Clotho is selected. In this example, node <em>A</em> knows all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> become Clotho’s. Node <em>A</em> prunes unnecessary information on its own structure. In this case, node <em>A</em> prunes the root set in the frame <span class="math inline"><em>f</em><sub>1</sub></span> since all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> become Clotho and the Clotho Check list stores the Clotho information.</p>
<h2 id="atropos-selection">Atropos Selection</h2>
<p>Atropos selection algorithm is the process in which the candidate time generated from Clotho selection is shared with other nodes, and each root re-selects candidate time repeatedly until all nodes have same candidate time for a Clotho.</p>
<p>After a Clotho is nominated, each node then computes a candidate time of the Clotho. If there are more than two-thirds of the nodes that compute the same value for candidate time, that time value is recorded. Otherwise, each node reselects candidate time. By the reselection process, each node reaches time consensus for candidate time of Clotho as the OPERA chain (DAG) grows. The candidate time reaching the consensus is called Atropos consensus time. After Atropos consensus time is computed, the Clotho is nominated to Atropos and each node stores the hash value of Atropos and Atropos consensus time in Main-Chain (blockchain). The Main-chain is used for time order between event blocks. The proof of Atropos consensus time selection is shown in the section [se:proof].</p>
<div class="figure">
<embed src="Atropos_fig1.pdf" height="302" />
<p class="caption">An Example of Atropos<span data-label="fig:Atropos"></span></p>
</div>
<p>Figure [fig:Atropos] shows the example of Atropos selection. In Figure [fig:Clotho], all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> are selected as Clotho through the existence of roots in the frame <span class="math inline"><em>f</em><sub>4</sub></span>. Each root in the frame <span class="math inline"><em>f</em><sub>5</sub></span> computes candidate time using timestamps of reachable roots in the frame <span class="math inline"><em>f</em><sub>4</sub></span>. Each root in the frame <span class="math inline"><em>f</em><sub>5</sub></span> stores the candidate time to min-max value space. The root <span class="math inline"><em>r</em><sub>6</sub></span> in the frame <span class="math inline"><em>f</em><sub>6</sub></span> can reach more than 2n/3 roots in <span class="math inline"><em>f</em><sub>5</sub></span> and <span class="math inline"><em>r</em><sub>6</sub></span> can know the candidate time of the reachable roots that <span class="math inline"><em>f</em><sub>5</sub></span> takes. If <span class="math inline"><em>r</em><sub>6</sub></span> knows the same candidate time than more than 2n/3, we select the candidate time as Atropos consensus time. Then all Clotho in the frame <span class="math inline"><em>f</em><sub>1</sub></span> become Atropos.</p>
<div class="figure">
<embed src="Atropos_fig2.pdf" />
<p class="caption">The node of <em>B</em> when Atropos is selected<span data-label="fig:Atropos_Node"></span></p>
</div>
<p>Figure [fig:Atropos_Node] shows the state of node <em>B</em> when Atropos is selected. In this example, node <em>B</em> knows all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> become Atropos. Then node <em>B</em> prunes information of the frame <span class="math inline"><em>f</em><sub>1</sub></span> in clotho check list since all roots in the frame <span class="math inline"><em>f</em><sub>1</sub></span> become Atropos and main chain stores Atropos information.</p>
<p>[H]</p>
<p><strong>Input</strong>: <span class="math inline"><em>c</em>.<em>C</em><em>l</em><em>o</em><em>t</em><em>h</em><em>o</em></span> in frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> <span class="math inline"><em>c</em>.<em>c</em><em>o</em><em>n</em><em>s</em><em>e</em><em>n</em><em>s</em><em>u</em><em>s</em>_<em>t</em><em>i</em><em>m</em><em>e</em></span> <span class="math inline">←</span> <span class="math inline"><em>n</em><em>i</em><em>l</em></span> <span class="math inline"><em>m</em></span> <span class="math inline">←</span> the index of the last frame <span class="math inline"><em>f</em><sub><em>m</em></sub></span> <span class="math inline"><em>R</em></span> <span class="math inline">←</span> be the Root set <span class="math inline"><em>R</em><sub><em>S</em><sub><em>i</em> + <em>d</em></sub></sub></span> in frame <span class="math inline"><em>f</em><sub><em>i</em> + <em>d</em></sub></span> <span class="math inline"><em>r</em>.<em>t</em><em>i</em><em>m</em><em>e</em>(<em>c</em>)</span> <span class="math inline">←</span> <span class="math inline"><em>r</em>.<em>l</em><em>a</em><em>m</em><em>p</em><em>o</em><em>r</em><em>t</em>_<em>t</em><em>i</em><em>m</em><em>e</em></span> s <span class="math inline">←</span> the set of Root in <span class="math inline"><em>f</em><sub><em>j</em> − 1</sub></span> that <span class="math inline"><em>r</em></span> can be happened-before with 2n/3 condition t <span class="math inline">←</span> RESELECTION(s, <span class="math inline"><em>c</em></span>) k <span class="math inline">←</span> the number of root having <span class="math inline"><em>t</em></span> in <span class="math inline"><em>s</em></span> <span class="math inline"><em>c</em>.<em>c</em><em>o</em><em>n</em><em>s</em><em>e</em><em>n</em><em>s</em><em>u</em><em>s</em>_<em>t</em><em>i</em><em>m</em><em>e</em></span> <span class="math inline">←</span> <span class="math inline"><em>t</em></span> <span class="math inline"><em>r</em>.<em>t</em><em>i</em><em>m</em><em>e</em>(<em>c</em>)</span> <span class="math inline">←</span> <span class="math inline"><em>t</em></span> <span class="math inline"><em>r</em>.<em>t</em><em>i</em><em>m</em><em>e</em>(<em>c</em>)</span> <span class="math inline">←</span> <span class="math inline"><em>t</em></span> <span class="math inline"><em>r</em>.<em>t</em><em>i</em><em>m</em><em>e</em>(<em>c</em>)</span> <span class="math inline">←</span> the minimum value in <span class="math inline"><em>s</em></span></p>
<p>[H]</p>
<p><span> ALG@cmd@@L @Function @currentfunction<span>Reselection</span></span> <span> bsphack @writeauxout<span> </span> esphack </span> <strong>Input</strong>: Root set <span class="math inline"><em>R</em></span>, and Clotho <span class="math inline"><em>c</em></span> <strong>Output</strong>: candidate time <span class="math inline"><em>t</em></span> <span class="math inline"><em>τ</em></span> <span class="math inline">←</span> set of all <span class="math inline"><em>t</em><sub><em>i</em></sub> = <em>r</em>.<em>t</em><em>i</em><em>m</em><em>e</em>(<em>c</em>)</span> for all <span class="math inline"><em>r</em></span> in <span class="math inline"><em>R</em></span> <span class="math inline"><em>D</em></span> <span class="math inline">←</span> set of tuples <span class="math inline">(<em>t</em><sub><em>i</em></sub>, <em>c</em><sub><em>i</em></sub>)</span> computed from <span class="math inline"><em>τ</em></span>, where <span class="math inline"><em>c</em><sub><em>i</em></sub> = <em>c</em><em>o</em><em>u</em><em>n</em><em>t</em>(<em>t</em><sub><em>i</em></sub>)</span> <span class="math inline"><em>m</em><em>a</em><em>x</em>_<em>c</em><em>o</em><em>u</em><em>n</em><em>t</em></span> <span class="math inline">←</span> <span class="math inline"><em>m</em><em>a</em><em>x</em>(<em>c</em><sub><em>i</em></sub>)</span> <span class="math inline"><em>t</em></span> <span class="math inline">←</span> <span class="math inline"><em>i</em><em>n</em><em>f</em><em>i</em><em>n</em><em>i</em><em>t</em><em>e</em></span> <span class="math inline"><em>t</em></span> <span class="math inline">←</span> <span class="math inline"><em>t</em><sub><em>i</em></sub></span> <strong>return</strong> <span class="math inline"><em>t</em></span></p>
<p>Algorithm [al:atc] and [al:resel] show pseudo code of Atropos consensus time selection and Consensus time reselection. In Algorithm [al:atc], at line 6, <span class="math inline"><em>d</em></span> saves the deference of relationship between root set of <span class="math inline"><em>c</em></span> and <span class="math inline"><em>w</em></span>. Thus, line 8 means that <span class="math inline"><em>w</em></span> is one of the elements in root set of the frame <span class="math inline"><em>f</em><sub><em>i</em> + 3</sub></span>, where the frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> includes <span class="math inline"><em>c</em></span>. Line 10, each root in the frame <span class="math inline"><em>f</em><sub><em>j</em></sub></span> selects own Lamport timestamp as candidate time of <span class="math inline"><em>c</em></span> when they confirm root <span class="math inline"><em>c</em></span> as Cltoho. In line 12, 13, and 14, <span class="math inline"><em>s</em></span>, <span class="math inline"><em>t</em></span>, and <span class="math inline"><em>k</em></span> save the set of root that <span class="math inline"><em>w</em></span> can be happened-before with 2n/3 condition <span class="math inline"><em>c</em></span>, the result of <span class="math inline"><em>R</em><em>E</em><em>S</em><em>E</em><em>L</em><em>E</em><em>C</em><em>T</em><em>I</em><em>O</em><em>N</em></span> function, and the number of root in <span class="math inline"><em>s</em></span> having <span class="math inline"><em>t</em></span>. Line 15 is checking whether there is a difference as much as <span class="math inline"><em>h</em></span> between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> where <span class="math inline"><em>h</em></span> is a constant value for minimum selection frame. Line 16-20 is checking whether more than two-thirds of root in the frame <span class="math inline"><em>f</em><sub><em>j</em> − 1</sub></span> nominate the same candidate time. If two-thirds of root in the frame <span class="math inline"><em>f</em><sub><em>j</em> − 1</sub></span> nominate the same candidate time, the root <span class="math inline"><em>c</em></span> is assigned consensus time as <span class="math inline"><em>t</em></span>. Line 22 is minimum selection frame. In minimum selection frame, minimum value of candidate time is selected to reach byzantine agreement. Algorithm [al:resel] operates in the middle of Algorithm [al:atc]. In Algorithm [al:resel], input is a root set <span class="math inline"><em>W</em></span> and output is a reselected candidate time. Line 4-5 computes the frequencies of each candidate time from all the roots in <span class="math inline"><em>W</em></span>. In line 6-11, a candidate time which is smallest time that is the most nomitated. The time complexity of Algorithm [al:resel] is <span class="math inline"><em>O</em>(<em>n</em>)</span> where <span class="math inline"><em>n</em></span> is the number of nodes. Since Algorithm [al:atc] includes Algorithm [al:resel], the time complexity of Algorithm [al:atc] is <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> where <span class="math inline"><em>n</em></span> is the number of nodes.</p>
<p>In the Atropos Consensus Time Selection algorithm, nodes reach consensus agreement about candidate time of a Clotho without additional communication (i.e., exchanging candidate time) with each other. Each node communicates with each other through the Lachesis protocol, the OPERA chain of all nodes grows up into same shape. This allows each node to know the candidate time of other nodes based on its OPERA chain and reach a consensus agreement. The proof that the agreement based on OPERA chain become agreement in action is shown in the section [se:proof].</p>
<p>Atropos can be determined by the consensus time of each Clotho. It is an event block that is determined by finality and is non-modifiable. Furthermore, all event blocks can be reached from Atropos guarantee finality.</p>
<h2 id="lachesis-consensus">Lachesis Consensus</h2>
<div class="figure">
<img src="pBFTtoPath" alt="Consensus Method in a DAG (combines chain with consensus process of pBFT)" height="264" />
<p class="caption">Consensus Method in a DAG (combines chain with consensus process of pBFT)<span data-label="fig:pBFTtoPath"></span></p>
</div>
<p>Figure [fig:pBFTtoPath] illustrates how consensus is reached through the domination relation in the OPERA chain. In the figure, leaf set, denoted by <span class="math inline"><em>R</em><sub><em>s</em>0</sub></span>, consists of the first event blocks created by individual participant nodes. <span class="math inline"><em>V</em></span> is the set of event blocks that do not belong neither in <span class="math inline"><em>R</em><sub><em>s</em>0</sub></span> nor in any root set <span class="math inline"><em>R</em><sub><em>s</em><em>i</em></sub></span>. Given a vertex <span class="math inline"><em>v</em></span> in <span class="math inline"><em>V</em> ∪ <em>R</em><sub><em>s</em><em>i</em></sub></span>, there exists a path from <span class="math inline"><em>v</em></span> that can reach a leaf vertex <span class="math inline"><em>u</em></span> in <span class="math inline"><em>R</em><sub><em>s</em>0</sub></span>. Let <span class="math inline"><em>r</em><sub>1</sub></span> and <span class="math inline"><em>r</em><sub>2</sub></span> be root event blocks in root set <span class="math inline"><em>R</em><sub><em>s</em>1</sub></span> and <span class="math inline"><em>R</em><sub><em>s</em>2</sub></span>, respectively. <span class="math inline"><em>r</em><sub>1</sub></span> is the block where a quorum or more blocks exist on a path that reaches a leaf event block. Every path from <span class="math inline"><em>r</em><sub>1</sub></span> to a leaf vertex will contain a vertex in <span class="math inline"><em>V</em><sub>1</sub></span>. Thus, if there exists a vertex <span class="math inline"><em>r</em></span> in <span class="math inline"><em>V</em><sub>1</sub></span> such that <span class="math inline"><em>r</em></span> is created by more than a quorum of participants, then <span class="math inline"><em>r</em></span> is already included in <span class="math inline"><em>R</em><sub><em>s</em>1</sub></span>. Likewise, <span class="math inline"><em>r</em><sub>2</sub></span> is a block that can be reached for <span class="math inline"><em>R</em><sub><em>s</em>1</sub></span> including <span class="math inline"><em>r</em><sub>1</sub></span> through blocks made by a quorum of participants. For all leaf event blocks that could be reached by <span class="math inline"><em>r</em><sub>1</sub></span>, they are connected with more than quorum participants through the presence of <span class="math inline"><em>r</em><sub>1</sub></span>. The existence of the root <span class="math inline"><em>r</em><sub>2</sub></span> shows that information of <span class="math inline"><em>r</em><sub>1</sub></span> is connected with more than a quorum. This kind of a path search allows the chain to reach consensus in a similar manner as the pBFT consensus processes. It is essential to keep track of the blocks satisfying the pBFT consensus process for quicker path search; our OPERA chain and Main-chain keep track of these blocks.</p>
<p>The sequential order of each event block is an important aspect for Byzantine fault tolerance. In order to determine the pre-and-post sequence between all event blocks, we use Atropos consensus time, Lamport timestamp algorithm and the hash value of the event block.</p>
<div class="figure">
<embed src="topological_ordering_rule.pdf" style="width:100.0%" />
<p class="caption">An example of topological consensus ordering<span data-label="fig:topological consensus ordering"></span></p>
</div>
<p>First, when each node creates event blocks, they have a logical timestamp based on Lamport timestamp. This means that they have a partial ordering between the relevant event blocks. Each Clotho has consensus time to the Atropos. This consensus time is computed based on the logical time nominated from other nodes at the time of the 2n/3 agreement.</p>
<p>Each event block is based on the following three rules to reach an agreement:</p>
<ol>
<li><p>If there are more than one Atropos with different times on the same frame, the event block with smaller consensus time has higher priority.</p></li>
<li><p>If there are more than one Atropos having any of the same consensus time on the same frame, determine the order based on the own logical time from Lamport timestamp.</p></li>
<li><p>When there are more than one Atropos having the same consensus time, if the local logical time is same, a smaller hash value is given priority through hash function.</p></li>
</ol>
<div class="figure">
<embed src="topological_ordering.pdf" style="width:90.0%" />
<p class="caption">An Example of time ordering of event blocks in OPERA chain<span data-label="fig:sequence of operachain"></span></p>
</div>
<p>Figure [fig:sequence of operachain] shows the part of OPERA chain in which the final consensus order is determined based on these 3 rules. The number represented by each event block is a logical time based on Lamport timestamp. Final topological consensus order containing the event blocks are based on agreement from the apropos. Based on each Atropos, they will have different colors depending on their range.</p>
<h2 id="detecting-forks">Detecting Forks</h2>
<p><span><span class="math inline"> </span> <strong><em>(Fork)</em></strong> <span>A pair of events (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> have the same creator, but neither is a self-ancestor of the other. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span>.</span></span></p>
<p>For example, let <span class="math inline"><em>v</em><sub><em>z</em></sub></span> be an event in node <span class="math inline"><em>n</em><sub>1</sub></span> and two child events <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> of <span class="math inline"><em>v</em><sub><em>z</em></sub></span>. if <span class="math inline"><em>v</em><sub><em>x</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>z</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>z</em></sub></span>, <span class="math inline">$v_x \not {\hookrightarrow^{s}}v_y$</span>, <span class="math inline">$v_y \not {\hookrightarrow^{s}}v_z$</span>, then (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork. The fork relation is symmetric; that is <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span> iff <span class="math inline"><em>v</em><sub><em>y</em></sub> ⋔ <em>v</em><sub><em>x</em></sub></span>.</p>
<p>By definition, (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork if <span class="math inline"><em>c</em><em>r</em>(<em>v</em><sub><em>x</em></sub>)=<em>c</em><em>r</em>(<em>v</em><sub><em>y</em></sub>)</span>, <span class="math inline">$v_x \not {\hookrightarrow^{a}}v_y$</span> and <span class="math inline">$v_y \not {\hookrightarrow^{a}}v_x$</span>. Using Happened-Before, the second part means <span class="math inline">$v_x \not \rightarrow v_y$</span> and <span class="math inline">$v_y \not \rightarrow v_x$</span>. By definition of concurrent, we get <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>If there is a fork <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span>, then <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> cannot both be roots on honest nodes.</p>
<p>Here, we show a proof by contradiction. Any honest node cannot accept a fork so <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> cannot be roots on the same honest node. Now we prove a more general case. Suppose that both <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a root of <span class="math inline"><em>n</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> is root of <span class="math inline"><em>n</em><sub><em>y</em></sub></span>, where <span class="math inline"><em>n</em><sub><em>x</em></sub></span> and <span class="math inline"><em>n</em><sub><em>y</em></sub></span> are honest nodes. Since <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a root, it reached events created by more than 2/3 of member nodes. Similarly, <span class="math inline"><em>v</em><sub><em>y</em></sub></span> is a root, it reached events created by more than 2/3 of member nodes. Thus, there must be an overlap of more than <span class="math inline"><em>n</em></span>/3 members of those events in both sets. Since we assume less than <span class="math inline"><em>n</em></span>/3 members are not honest, so there must be at least one honest member in the overlap set. Let <span class="math inline"><em>n</em><sub><em>m</em></sub></span> be such an honest member. Because <span class="math inline"><em>n</em><sub><em>m</em></sub></span> is honest, <span class="math inline"><em>n</em><sub><em>m</em></sub></span> does not allow the fork.</p>
<h1 id="se:con">Conclusion</h1>
<p>We further optimize the OPERA chain and Main-chain for faster consensus. By using Lamport timestamps and domination relation, the topological ordering of event blocks in OPERA chain and Main chain is more intuitive and reliable in distributed system.</p>
<p>We have presented a formal semantics for Lachesis protocol in Section [se:lca]. Our formal proof of pBFT for our Lachesis protocol is given in Section [se:proof]. Our work is the first that studies such concurrent common knowledge sematics <span class="citation"></span> and dominator relationships in DAG-based protocols.</p>
<h1 id="se:appendix">Appendix</h1>
<h2 id="preliminaries">Preliminaries</h2>
<p>The history of a Lachesis protocol can be represented by a directed acyclic graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>, where <span class="math inline"><em>V</em></span> is a set of vertices and <span class="math inline"><em>E</em></span> is a set of edges. Each vertex in a row (node) represents an event. Time flows left-to-right of the graph, so left vertices represent earlier events in history. A path <span class="math inline"><em>p</em></span> in <span class="math inline"><em>G</em></span> is a sequence of vertices (<span class="math inline"><em>v</em><sub>1</sub></span>, <span class="math inline"><em>v</em><sub>2</sub></span>, <span class="math inline">…</span>, <span class="math inline"><em>v</em><sub><em>k</em></sub></span>) by following the edges in <span class="math inline"><em>E</em></span>. Let <span class="math inline"><em>v</em><sub><em>c</em></sub></span> be a vertex in <span class="math inline"><em>G</em></span>. A vertex <span class="math inline"><em>v</em><sub><em>p</em></sub></span> is the <em>parent</em> of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is an edge from <span class="math inline"><em>v</em><sub><em>p</em></sub></span> to <span class="math inline"><em>v</em><sub><em>c</em></sub></span>. A vertex <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is an <em>ancestor</em> of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a path from <span class="math inline"><em>v</em><sub><em>a</em></sub></span> to <span class="math inline"><em>v</em><sub><em>c</em></sub></span>.</p>
<p>Each machine that participates in the Lachesis protocol is called a node.</p>
<p>Let <span class="math inline"><em>n</em></span> denote the total number of nodes.</p>
<p>Each node can create event blocks, send (receive) messages to (from) other nodes.</p>
<p>An event block is a vertex of the OPERA chain.</p>
<p>Suppose a node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> creates an event <span class="math inline"><em>v</em><sub><em>c</em></sub></span> after an event <span class="math inline"><em>v</em><sub><em>s</em></sub></span> in <span class="math inline"><em>n</em><sub><em>i</em></sub></span>. Each event block has exactly <span class="math inline"><em>k</em></span> references. One of the references is self-reference, and the other <span class="math inline"><em>k</em></span>-1 references point to the top events of <span class="math inline"><em>n</em><sub><em>i</em></sub></span>’s <span class="math inline"><em>k</em></span>-1 peer nodes.</p>
<p>A node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> has <span class="math inline"><em>k</em></span> peer nodes.</p>
<p>An event <span class="math inline"><em>v</em></span> is a top event of a node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> if there is no other event in <span class="math inline"><em>n</em><sub><em>i</em></sub></span> referencing <span class="math inline"><em>v</em></span>.</p>
<p>An event <span class="math inline"><em>v</em><sub><em>s</em></sub></span> is called “self-ref&quot; of event <span class="math inline"><em>v</em><sub><em>c</em></sub></span>, if the self-ref hash of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> points to the event <span class="math inline"><em>v</em><sub><em>s</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>s</em></sub></span>.</p>
<p>An event <span class="math inline"><em>v</em><sub><em>r</em></sub></span> is called “ref&quot; of event <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if the reference hash of <span class="math inline"><em>v</em><sub><em>c</em></sub></span> points to the event <span class="math inline"><em>v</em><sub><em>r</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>r</em></sup><em>v</em><sub><em>r</em></sub></span>.</p>
<p>For simplicity, we can use <span class="math inline">↪</span> to denote a reference relationship (either <span class="math inline">↪<sup><em>r</em></sup></span> or <span class="math inline">↪<sup><em>s</em></sup></span>).</p>
<p>An event block <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is self-ancestor of an event block <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a sequence of events such that <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em></sup><em>v</em><sub>1</sub>↪<sup><em>s</em></sup>…↪<sup><em>s</em></sup><em>v</em><sub><em>m</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>a</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>s</em><em>a</em></sup><em>v</em><sub><em>a</em></sub></span>.</p>
<p>An event block <span class="math inline"><em>v</em><sub><em>a</em></sub></span> is an ancestor of an event block <span class="math inline"><em>v</em><sub><em>c</em></sub></span> if there is a sequence of events such that <span class="math inline"><em>v</em><sub><em>c</em></sub> ↪ <em>v</em><sub>1</sub> ↪ … ↪ <em>v</em><sub><em>m</em></sub> ↪ <em>v</em><sub><em>a</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>a</em></sub></span>.</p>
<p>For simplicity, we simply use <span class="math inline"><em>v</em><sub><em>c</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>s</em></sub></span> to refer both ancestor and self-ancestor relationship, unless we need to distinguish the two cases.</p>
<p>OPERA chain is a DAG graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> consisting of <span class="math inline"><em>V</em></span> vertices and <span class="math inline"><em>E</em></span> edges. Each vertex <span class="math inline"><em>v</em><sub><em>i</em></sub> ∈ <em>V</em></span> is an event block. An edge <span class="math inline">(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)∈<em>E</em></span> refers to a hashing reference from <span class="math inline"><em>v</em><sub><em>i</em></sub></span> to <span class="math inline"><em>v</em><sub><em>j</em></sub></span>; that is, <span class="math inline"><em>v</em><sub><em>i</em></sub> ↪ <em>v</em><sub><em>j</em></sub></span>.</p>
<h3 id="domination-relation-1">Domination relation</h3>
<p>Then we define the domination relation for event blocks. To begin with, we first introduce pseudo vertices, <em>top</em> and <em>bot</em>, of the DAG OPERA chain <span class="math inline"><em>G</em></span>.</p>
<p>A pseudo vertex, called top, is the parent of all top event blocks. Denoted by <span class="math inline">⊤</span>.</p>
<p>A pseudo vertex, called bottom, is the child of all leaf event blocks. Denoted by <span class="math inline">⊥</span>.</p>
<p>With the pseudo vertices, we have <span class="math inline">⊥</span> happened before all event blocks. Also all event blocks happened before <span class="math inline">⊤</span>. That is, for all event <span class="math inline"><em>v</em><sub><em>i</em></sub></span>, <span class="math inline">⊥ → <em>v</em><sub><em>i</em></sub></span> and <span class="math inline"><em>v</em><sub><em>i</em></sub> → ⊤</span>.</p>
<p>An event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if every path from <span class="math inline">⊤</span> to <span class="math inline"><em>v</em><sub><em>x</em></sub></span> must go through <span class="math inline"><em>v</em><sub><em>d</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub> ≫ <em>v</em><sub><em>x</em></sub></span>.</p>
<p>An event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> strictly dominates an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if <span class="math inline"><em>v</em><sub><em>d</em></sub> ≫ <em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>d</em></sub></span> does not equal <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>s</em></sup><em>v</em><sub><em>x</em></sub></span>.</p>
<p>A vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> is said “domfront” a vertex <span class="math inline"><em>v</em><sub><em>x</em></sub></span> if <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates an immediate predecessor of <span class="math inline"><em>v</em><sub><em>x</em></sub></span>, but <span class="math inline"><em>v</em><sub><em>d</em></sub></span> does not strictly dominate <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>.</p>
<p>The dominance frontier of a vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> is the set of all nodes <span class="math inline"><em>v</em><sub><em>x</em></sub></span> such that <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>. Denoted by <span class="math inline"><em>D</em><em>F</em>(<em>v</em><sub><em>d</em></sub>)</span>.</p>
<p>From the above definitions of domfront and dominance frontier, the following holds. If <span class="math inline"><em>v</em><sub><em>d</em></sub>≫<sup><em>f</em></sup><em>v</em><sub><em>x</em></sub></span>, then <span class="math inline"><em>v</em><sub><em>x</em></sub> ∈ <em>D</em><em>F</em>(<em>v</em><sub><em>d</em></sub>)</span>.</p>
<p>Here, we introduce a new idea that extends the concept domination.</p>
<p>For a vertex <span class="math inline"><em>v</em></span> in a DAG <span class="math inline"><em>G</em></span>, let <span class="math inline"><em>G</em>[<em>v</em>]=(<em>V</em><sub><em>v</em></sub>, <em>E</em><sub><em>v</em></sub>)</span> denote an induced-subgraph of <span class="math inline"><em>G</em></span> such that <span class="math inline"><em>V</em><sub><em>v</em></sub></span> consists of all ancestors of <span class="math inline"><em>v</em></span> including <span class="math inline"><em>v</em></span>, and <span class="math inline"><em>E</em><sub><em>v</em></sub></span> is the induced edges of <span class="math inline"><em>V</em><sub><em>v</em></sub></span> in <span class="math inline"><em>G</em></span>.</p>
<p>For a set <span class="math inline"><em>S</em></span> of vertices, an event <span class="math inline"><em>v</em><sub><em>d</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>S</em></span> if there are more than 2/3 of vertices <span class="math inline"><em>v</em><sub><em>x</em></sub></span> in <span class="math inline"><em>S</em></span> such that <span class="math inline"><em>v</em><sub><em>d</em></sub></span> dominates <span class="math inline"><em>v</em><sub><em>x</em></sub></span>. Recall that <span class="math inline"><em>R</em><sub>1</sub></span> is the set of all leaf vertices in <span class="math inline"><em>G</em></span>. The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub>0</sub></span> is the same as the set <span class="math inline"><em>R</em><sub>1</sub></span>.The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>i</em></sub></span> is defined as follows:</p>
<p>A vertex <span class="math inline"><em>v</em><sub><em>d</em></sub></span> belongs to a <span class="math inline">$\frac{2}{3}$</span>-dom set within the graph <span class="math inline"><em>G</em>[<em>v</em><sub><em>d</em></sub>]</span>, if <span class="math inline"><em>v</em><sub><em>d</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>R</em><sub>1</sub></span>. The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>k</em></sub></span> consists of all roots <span class="math inline"><em>d</em><sub><em>i</em></sub></span> such that <span class="math inline"><em>d</em><sub><em>i</em></sub></span> <span class="math inline">∉</span> <span class="math inline"><em>D</em><sub><em>i</em></sub></span>, <span class="math inline">∀</span> <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1), and <span class="math inline"><em>d</em><sub><em>i</em></sub></span> <span class="math inline">$\frac{2}{3}$</span>-dominates <span class="math inline"><em>D</em><sub><em>i</em> − 1</sub></span>.</p>
<p>The <span class="math inline">$\frac{2}{3}$</span>-dom set <span class="math inline"><em>D</em><sub><em>i</em></sub></span> is the same with the root set <span class="math inline"><em>R</em><sub><em>i</em></sub></span>, for all nodes.</p>
<h2 id="se:proof">Proof of Lachesis Consensus Algorithm</h2>
<p>This section presents a proof of liveness and safety of our Lachesis protocols. We aim to show that our consensus is Byzantine fault tolerant with a presumption that more than two-thirds of participants are reliable nodes. We first provide some definitions, lemmas and theorems. Then we validate the Byzantine fault tolerance.</p>
<h3 id="proof-of-byzantine-fault-tolerance-for-lachesis-consensus-algorithm">Proof of Byzantine Fault Tolerance for Lachesis Consensus Algorithm</h3>
<p>An event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is said Happened-Immediate-Before an event block <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a (self-) ref of <span class="math inline"><em>v</em><sub><em>y</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ↦ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>An event block <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is said Happened-Before an event block <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a (self-) ancestor of <span class="math inline"><em>v</em><sub><em>y</em></sub></span>. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span>.</p>
<p>The happens-before relation is the transitive closure of happens-immediately-before. Thus, an event <span class="math inline"><em>v</em><sub><em>x</em></sub></span> happened before an event <span class="math inline"><em>v</em><sub><em>y</em></sub></span> if one of the followings happens: (a) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>x</em></sub></span>, (b) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>r</em></sup><em>v</em><sub><em>x</em></sub></span>, or (c) <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>x</em></sub></span>. We come up with the following proposition:</p>
<p><span class="math inline"><em>v</em><sub><em>x</em></sub> ↦ <em>v</em><sub><em>y</em></sub></span> iff <span class="math inline"><em>v</em><sub><em>y</em></sub> ↪ <em>v</em><sub><em>x</em></sub></span> iff edge <span class="math inline">(<em>v</em><sub><em>y</em></sub>, <em>v</em><sub><em>x</em></sub>)</span> <span class="math inline">∈<em>E</em></span> of OPERA chain.</p>
<p><span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span> iff <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>a</em></sup><em>v</em><sub><em>x</em></sub></span>.</p>
<p>Two event blocks <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> are said concurrent if neither of them happened before the other. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>Given two vertices <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> both contained in two OPERA chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> on two nodes. We have the following: (1) <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span> iff <span class="math inline"><em>v</em><sub><em>x</em></sub> → <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>; (2) <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span> iff <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>.</p>
<p>Below is some main definitions in Lachesis protocol.</p>
<p>The first created event block of a node is called a leaf event block.</p>
<p>[def:root] The leaf event block of a node is a root. When an event block <span class="math inline"><em>v</em></span> can reach more than <span class="math inline">2<em>n</em>/3</span> of the roots in the previous frames, <span class="math inline"><em>v</em></span> becomes a root.</p>
<p>The set of all first event blocks (leaf events) of all nodes form the first root set <span class="math inline"><em>R</em><sub>1</sub></span> (<span class="math inline">|<em>R</em><sub>1</sub>|</span> = <span class="math inline"><em>n</em></span>). The root set <span class="math inline"><em>R</em><sub><em>k</em></sub></span> consists of all roots <span class="math inline"><em>r</em><sub><em>i</em></sub></span> such that <span class="math inline"><em>r</em><sub><em>i</em></sub></span> <span class="math inline">∉</span> <span class="math inline"><em>R</em><sub><em>i</em></sub></span>, <span class="math inline">∀</span> <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1) and <span class="math inline"><em>r</em><sub><em>i</em></sub></span> can reach more than 2n/3 other roots in the current frame, <span class="math inline"><em>i</em></span> = 1..(<span class="math inline"><em>k</em></span>-1).</p>
<p>Frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> is a natural number that separates Root sets.</p>
<p>The root set at frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> is denoted by <span class="math inline"><em>R</em><sub><em>i</em></sub></span>.</p>
<p>[dfn:conchains] OPERA chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are consistent iff for any event <span class="math inline"><em>v</em></span> contained in both chains, <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]=<em>G</em><sub>2</sub>[<em>v</em>]</span>. Denoted by <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>.</p>
<p>When two consistent chains contain the same event <span class="math inline"><em>v</em></span>, both chains contain the same set of ancestors for <span class="math inline"><em>v</em></span>, with the same reference and self-ref edges between those ancestors:</p>
<p>[thm:conchains] All nodes have consistent OPERA chains.</p>
<p>If two nodes have OPERA chains containing event <span class="math inline"><em>v</em></span>, then they have the same <span class="math inline"><em>k</em></span> hashes contained within <span class="math inline"><em>v</em></span>. A node will not accept an event during a sync unless that node already has <span class="math inline"><em>k</em></span> references for that event, so both OPERA chains must contain <span class="math inline"><em>k</em></span> references for <span class="math inline"><em>v</em></span>. The cryptographic hashes are assumed to be secure, therefore the references must be the same. By induction, all ancestors of <span class="math inline"><em>v</em></span> must be the same. Therefore, the two OPERA chains are consistent.</p>
<p>If a node <span class="math inline"><em>n</em><sub><em>x</em></sub></span> creates an event block <span class="math inline"><em>v</em></span>, then the creator of <span class="math inline"><em>v</em></span>, denoted by <span class="math inline"><em>c</em><em>r</em>(<em>v</em>)</span>, is <span class="math inline"><em>n</em><sub><em>x</em></sub></span>.</p>
<p>The pair of events (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork if <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> have the same creator, but neither is a self-ancestor of the other. Denoted by <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>For example, let <span class="math inline"><em>v</em><sub><em>z</em></sub></span> be an event in node <span class="math inline"><em>n</em><sub>1</sub></span> and two child events <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> of <span class="math inline"><em>v</em><sub><em>z</em></sub></span>. if <span class="math inline"><em>v</em><sub><em>x</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>z</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub>↪<sup><em>s</em></sup><em>v</em><sub><em>z</em></sub></span>, <span class="math inline">$v_x \not {\hookrightarrow^{s}}v_y$</span>, <span class="math inline">$v_y \not {\hookrightarrow^{s}}v_z$</span>, then (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork. The fork relation is symmetric; that is <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span> iff <span class="math inline"><em>v</em><sub><em>y</em></sub> ⋔ <em>v</em><sub><em>x</em></sub></span>.</p>
<p><span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span> iff <span class="math inline"><em>c</em><em>r</em>(<em>v</em><sub><em>x</em></sub>)=<em>c</em><em>r</em>(<em>v</em><sub><em>y</em></sub>)</span> and <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>By definition, (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is a fork if <span class="math inline"><em>c</em><em>r</em>(<em>v</em><sub><em>x</em></sub>)=<em>c</em><em>r</em>(<em>v</em><sub><em>y</em></sub>)</span>, <span class="math inline">$v_x \not {\hookrightarrow^{a}}v_y$</span> and <span class="math inline">$v_y \not {\hookrightarrow^{a}}v_x$</span>. Using Happened-Before, the second part means <span class="math inline">$v_x \not \rightarrow v_y$</span> and <span class="math inline">$v_y \not \rightarrow v_x$</span>. By definition of concurrent, we get <span class="math inline"><em>v</em><sub><em>x</em></sub> ∥ <em>v</em><sub><em>y</em></sub></span>.</p>
<p>(fork detection). If there is a fork <span class="math inline"><em>v</em><sub><em>x</em></sub> ⋔ <em>v</em><sub><em>y</em></sub></span>, then <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> cannot both be roots on honest nodes.</p>
<p>Here, we show a proof by contradiction. Any honest node cannot accept a fork so <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> cannot be roots on the same honest node. Now we prove a more general case. Suppose that both <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a root of <span class="math inline"><em>n</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> is root of <span class="math inline"><em>n</em><sub><em>y</em></sub></span>, where <span class="math inline"><em>n</em><sub><em>x</em></sub></span> and <span class="math inline"><em>n</em><sub><em>y</em></sub></span> are honest nodes. Since <span class="math inline"><em>v</em><sub><em>x</em></sub></span> is a root, it reached events created by more than 2/3 of member nodes. Similary, <span class="math inline"><em>v</em><sub><em>y</em></sub></span> is a root, it reached events created by more than 2/3 of member nodes. Thus, there must be an overlap of more than <span class="math inline"><em>n</em></span>/3 members of those events in both sets. Since we assume less than <span class="math inline"><em>n</em></span>/3 members are not honest, so there must be at least one honest member in the overlap set. Let <span class="math inline"><em>n</em><sub><em>m</em></sub></span> be such an honest member. Because <span class="math inline"><em>n</em><sub><em>m</em></sub></span> is honest, <span class="math inline"><em>n</em><sub><em>m</em></sub></span> does not allow the fork. This contradicts the assumption. Thus, the lemma is proved.</p>
<p>Each node <span class="math inline"><em>n</em><sub><em>i</em></sub></span> has an OPERA chain <span class="math inline"><em>G</em><sub><em>i</em></sub></span>. We define a consistent chain from a sequence of OPERA chain <span class="math inline"><em>G</em><sub><em>i</em></sub></span>.</p>
<p>A global consistent chain <span class="math inline"><em>G</em><sup><em>C</em></sup></span> is a chain if <span class="math inline"><em>G</em><sup><em>C</em></sup> ∼ <em>G</em><sub><em>i</em></sub></span> for all <span class="math inline"><em>G</em><sub><em>i</em></sub></span>.</p>
<p>We denote <span class="math inline"><em>G</em> ⊑ <em>G</em>′</span> to stand for <span class="math inline"><em>G</em></span> is a subgraph of <span class="math inline"><em>G</em>′</span>.</p>
<p><span class="math inline">∀<em>G</em><sub><em>i</em></sub></span> (<span class="math inline"><em>G</em><sup><em>C</em></sup> ⊑ <em>G</em><sub><em>i</em></sub></span>).</p>
<p><span class="math inline">∀<em>v</em> ∈ <em>G</em><sup><em>C</em></sup></span> <span class="math inline">∀<em>G</em><sub><em>i</em></sub></span> (<span class="math inline"><em>G</em><sup><em>C</em></sup>[<em>v</em>]⊑<em>G</em><sub><em>i</em></sub>[<em>v</em>]</span>).</p>
<p>(<span class="math inline">∀<em>v</em><sub><em>c</em></sub> ∈ <em>G</em><sup><em>C</em></sup></span>) (<span class="math inline">∀<em>v</em><sub><em>p</em></sub> ∈ <em>G</em><sub><em>i</em></sub></span>) ((<span class="math inline"><em>v</em><sub><em>p</em></sub> → <em>v</em><sub><em>c</em></sub>)⇒<em>v</em><sub><em>p</em></sub> ∈ <em>G</em><sup><em>C</em></sup></span>).</p>
<p>Now we state the following important propositions.</p>
<p>Two chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are root consistent, if for every <span class="math inline"><em>v</em></span> contained in both chains, and <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub>1</sub></span>, then <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub>2</sub></span>.</p>
<p>If <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, then <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are root consistent.</p>
<p>By consistent chains, if <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span> and <span class="math inline"><em>v</em></span> belongs to both chains, then <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]</span> = <span class="math inline"><em>G</em><sub>2</sub>[<em>v</em>]</span>. We can prove the proposition by induction. For <span class="math inline"><em>j</em></span> = 0, the first root set is the same in both <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span>. Hence, it holds for <span class="math inline"><em>j</em></span> = 0. Suppose that the proposition holds for every <span class="math inline"><em>j</em></span> from 0 to <span class="math inline"><em>k</em></span>. We prove that it also holds for <span class="math inline"><em>j</em></span>= <span class="math inline"><em>k</em></span> + 1. Suppose that <span class="math inline"><em>v</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em> + 1</sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span>. Then there exists a set <span class="math inline"><em>S</em></span> reaching 2/3 of members in <span class="math inline"><em>G</em><sub>1</sub></span> of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> such that <span class="math inline">∀<em>u</em> ∈ <em>S</em></span> (<span class="math inline"><em>u</em> → <em>v</em></span>). As <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, and <span class="math inline"><em>v</em></span> in <span class="math inline"><em>G</em><sub>2</sub></span>, then <span class="math inline">∀<em>u</em> ∈ <em>S</em></span> (<span class="math inline"><em>u</em> ∈ <em>G</em><sub>2</sub></span>). Since the proposition holds for <span class="math inline"><em>j</em></span>=<span class="math inline"><em>k</em></span>, As <span class="math inline"><em>u</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span>, <span class="math inline"><em>u</em></span> is a root of frame <span class="math inline"><em>f</em><sub><em>k</em></sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>. Hence, the set <span class="math inline"><em>S</em></span> of 2/3 members <span class="math inline"><em>u</em></span> happens before <span class="math inline"><em>v</em></span> in <span class="math inline"><em>G</em><sub>2</sub></span>. So <span class="math inline"><em>v</em></span> belongs to <span class="math inline"><em>f</em><sub><em>k</em> + 1</sub></span> in <span class="math inline"><em>G</em><sub>2</sub></span>. The proposition is proved.</p>
<p>From the above proposition, one can deduce the following:</p>
<p><span class="math inline"><em>G</em><sup><em>C</em></sup></span> is root consistent with <span class="math inline"><em>G</em><sub><em>i</em></sub></span> for all nodes.</p>
<p>Thus, all nodes have the same consistent root sets, which are the root sets in <span class="math inline"><em>G</em><sup><em>C</em></sup></span>. Frame numbers are consistent for all nodes.</p>
<p>For any top event <span class="math inline"><em>v</em></span> in both OPERA chains <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span>, and <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, then the flag tables of <span class="math inline"><em>v</em></span> are consistent iff they are the same in both chains.</p>
<p>From the above lemmas, the root sets of <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> are consistent. If <span class="math inline"><em>v</em></span> contained in <span class="math inline"><em>G</em><sub>1</sub></span>, and <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sup>1</sup></span>, then <span class="math inline"><em>v</em></span> is a root of <span class="math inline"><em>j</em></span>-th frame in <span class="math inline"><em>G</em><sub><em>i</em></sub></span>. Since <span class="math inline"><em>G</em><sub>1</sub> ∼ <em>G</em><sub>2</sub></span>, <span class="math inline"><em>G</em><sub>1</sub>[<em>v</em>]=<em>G</em><sub>2</sub>[<em>v</em>]</span>. The reference event blocks of <span class="math inline"><em>v</em></span> are the same in both chains. Thus the flag tables of <span class="math inline"><em>v</em></span> of both chains are the same.</p>
<p>Thus, all nodes have consistent flag tables.</p>
<p>A root <span class="math inline"><em>r</em><sub><em>k</em></sub></span> in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 3</sub></span> can nominate a root <span class="math inline"><em>r</em><sub><em>a</em></sub></span> as Clotho if more than 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 1</sub></span> Happened-Before <span class="math inline"><em>r</em><sub><em>a</em></sub></span> and <span class="math inline"><em>r</em><sub><em>k</em></sub></span> Happened-Before the roots in the frame <span class="math inline"><em>f</em><sub><em>a</em> + 1</sub></span>.</p>
<p>[lem:root] For any root set <span class="math inline"><em>R</em></span>, all nodes nominate same root into Clotho.</p>
<p>Based on Theorem [thm:same], each node nominates a root into Clotho via the flag table. If all nodes have an OPERA chain with same shape, the values in flag table should be equal to each other in OPERA chain. Thus, all nodes nominate the same root into Clotho since the OPERA chain of all nodes has same shape.</p>
<p>[lem:resel] In the Reselection algorithm, for any Clotho, a root in OPERA chain selects the same consensus time candidate.</p>
<p>Based on Theorem [thm:same], if all nodes have an OPERA chain with the same partial shape, a root in OPERA chain selects the same consensus time candidate by the Reselection algorithm.</p>
<p>[lem:fork] If the pair of event blocks (x,y) is fork and a root has Happened-before the fork, this fork is detected in the Clotho selection process.</p>
<p>We show a proof by contradiction. Assume that no node can detect the fork in the Clotho selection process.</p>
<p>Assume that there is a root <span class="math inline"><em>r</em><sub><em>i</em></sub></span> that becomes Clotho in <span class="math inline"><em>f</em><sub><em>i</em></sub></span>, which was selected as Clotho by n/3 of the roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span>. More than 2n/3 roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> should have happened-before by a root in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span>. If a pair (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) is fork, There are two cases: (1) assume that <span class="math inline"><em>r</em><sub><em>i</em></sub></span> is one of <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span>, (2) assume that <span class="math inline"><em>r</em><sub><em>i</em></sub></span> can reach both <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span>.</p>
<p>Our proof for both two cases is as follows.</p>
<p>Let <span class="math inline"><em>k</em></span> denote that the number of roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> that can reach <span class="math inline"><em>r</em><sub><em>i</em></sub></span> in <span class="math inline"><em>f</em><sub><em>i</em></sub></span> (<span class="math inline">∴</span> n/3 <span class="math inline">&lt;</span> <span class="math inline"><em>k</em></span>).</p>
<p>In order to select root in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span>, the root in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> should reach more than 2n/3 of roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> by Definition [def:root]. At the moment, assume that <span class="math inline"><em>l</em></span> is the number of roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> that can be reached by the root in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> (<span class="math inline">∴</span> 2n/3 <span class="math inline">&lt;</span> <span class="math inline"><em>l</em></span>).</p>
<p>At this time, n <span class="math inline">&lt;</span> k + l (<span class="math inline">∵</span> n/3 + 2n/3 <span class="math inline">&lt;</span> <span class="math inline"><em>k</em></span> + <span class="math inline"><em>l</em></span>), there are (n - <span class="math inline"><em>k</em></span> + <span class="math inline"><em>l</em></span>) roots in frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> that should reach <span class="math inline"><em>r</em><sub><em>i</em></sub></span> in <span class="math inline"><em>f</em><sub><em>i</em></sub></span> and all roots in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> should reach at least n – <span class="math inline"><em>k</em></span> + <span class="math inline"><em>l</em></span> of roots in <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span>. It means that all roots in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> know the existence of <span class="math inline"><em>r</em><sub><em>i</em></sub></span>. Therefore, the node that generated all the roots of <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> detect the fork in the Clotho selection of <span class="math inline"><em>r</em><sub><em>i</em></sub></span>, which contradicts the assumption.</p>
<p>It can be covered two cases. If <span class="math inline"><em>r</em><sub><em>i</em></sub></span> is part of the fork, we can detect in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span>. If there is fork (<span class="math inline"><em>v</em><sub><em>x</em></sub></span>, <span class="math inline"><em>v</em><sub><em>y</em></sub></span>) that can be reached by <span class="math inline"><em>r</em><sub><em>i</em></sub></span>, it also can be detected in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span> since we can detect the fork in the Clotho selection of <span class="math inline"><em>r</em><sub><em>i</em></sub></span> and it indicates that all event blocks that can be reached by <span class="math inline"><em>r</em><sub><em>i</em></sub></span> are detected by the roots in <span class="math inline"><em>f</em><sub><em>i</em> + 2</sub></span>.</p>
<p>For a root <span class="math inline"><em>v</em></span> happened-before a fork in OPERA chain, <span class="math inline"><em>v</em></span> must see the fork before becoming Clotho.</p>
<p>Suppose that a node creates two event blocks (<span class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub></span>), which forms a fork. To create two Clothos that can reach both events, the event blocks should reach by more than 2n/3 nodes. Therefore, the OPERA chain can structurally detect the fork before roots become Clotho.</p>
<p>[thm:same] All nodes grows up into same consistent OPERA chain <span class="math inline"><em>G</em><sup><em>C</em></sup></span>, which contains no fork.</p>
<p>Suppose that there are two event blocks <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> contained in both <span class="math inline"><em>G</em><sub>1</sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span>, and their path between <span class="math inline"><em>v</em><sub><em>x</em></sub></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub></span> in <span class="math inline"><em>G</em><sub>1</sub></span> is not equal to that in <span class="math inline"><em>G</em><sub>2</sub></span>. We can consider that the path difference between the nodes is a kind of fork attack. Based on Lemma [lem:fork], if an attacker forks an event block, each chain of <span class="math inline"><em>G</em><sub><em>i</em></sub></span> and <span class="math inline"><em>G</em><sub>2</sub></span> can detect and remove the fork before the Clotho is generated. Thus, any two nodes have consistent OPERA chain.</p>
<p>If the consensus time of Clotho is validated, the Clotho become an Atropos.</p>
<p>[thm:ct] Lachesis consensus algorithm guarantees to reach agreement for the consensus time.</p>
<p>For any root set <span class="math inline"><em>R</em></span> in the frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span>, time consensus algorithm checks whether more than 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> − 1</sub></span> selects the same value. However, each node selects one of the values collected from the root set in the previous frame by the time consensus algorithm and Reselection process. Based on the Reselection process, the time consensus algorithm can reach agreement. However, there is a possibility that consensus time candidate does not reach agreement <span class="citation"></span>. To solve this problem, time consensus algorithm includes minimal selection frame per next <span class="math inline"><em>h</em></span> frame. In minimal value selection algorithm, each root selects minimum value among values collected from previous root set. Thus, the consensus time reaches consensus by time consensus algorithm.</p>
<p>[thm:bft] If the number of reliable nodes is more than <span class="math inline">2<em>n</em>/3</span>, event blocks created by reliable nodes must be assigned to consensus order.</p>
<p>In OPERA chain, since reliable nodes try to create event blocks by communicating with every other nodes continuously, reliable nodes will share the event block <span class="math inline"><em>x</em></span> with each other. If a root <span class="math inline"><em>y</em></span> in the frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> Happened-Before event block <span class="math inline"><em>x</em></span> and more than n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> Happened-Before the root <span class="math inline"><em>y</em></span>, the root <span class="math inline"><em>y</em></span> will be nominated as Clotho and Atropos. Thus, event block <span class="math inline"><em>x</em></span> and root <span class="math inline"><em>y</em></span> will be assigned consensus time <span class="math inline"><em>t</em></span>.</p>
<p>For an event block, assigning consensus time means that the validated event block is shared by more than 2n/3 nodes. Therefore, malicious node cannot try to attack after the event blocks are assigned consensus time. When the event block <span class="math inline"><em>x</em></span> has consensus time <span class="math inline"><em>t</em></span>, it cannot occur to discover new event blocks with earlier consensus time than <span class="math inline"><em>t</em></span>. There are two conditions to be assigned consensus time earlier than <span class="math inline"><em>t</em></span> for new event blocks. First, a root <span class="math inline"><em>r</em></span> in the frame <span class="math inline"><em>f</em><sub><em>i</em></sub></span> should be able to share new event blocks. Second, the more than 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> should be able to share <span class="math inline"><em>r</em></span>. Even if the first condition is satisfied by malicious nodes (e.g., parasite chain), the second condition cannot be satisfied since at least 2n/3 roots in the frame <span class="math inline"><em>f</em><sub><em>i</em> + 1</sub></span> are already created and cannot be changed. Therefore, after an event block is validated, new event blocks should not be participate earlier consensus time to OPERA chain.</p>
<h2 id="sec:semantics">Semantics of Lachesis protocol</h2>
<p>This section gives the formal semantics of Lachesis consensus protocol. We use CCK model <span class="citation"></span> of an asynchronous system as the base of the semantics of our Lachesis protocol. Events are ordered based on Lamport’s happens-before relation. In particular, we use Lamport’s theory to describe global states of an asynchronous system.</p>
<p>We present notations and concepts, which are important for Lachesis protocol. In several places, we adapt the notations and concepts of CCK paper to suit our Lachesis protocol.</p>
<p>An asynchronous system consists of the following:</p>
<p>A process <span class="math inline"><em>p</em><sub><em>i</em></sub></span> represents a machine or a node. The process identifier of <span class="math inline"><em>p</em><sub><em>i</em></sub></span> is <span class="math inline"><em>i</em></span>. A set <span class="math inline"><em>P</em></span> = {1,...,<span class="math inline"><em>n</em></span>} denotes the set of process identifiers.</p>
<p>A process <span class="math inline"><em>i</em></span> can send messages to process <span class="math inline"><em>j</em></span> if there is a channel (<span class="math inline"><em>i</em></span>,<span class="math inline"><em>j</em></span>). Let <span class="math inline"><em>C</em></span> <span class="math inline">⊆</span> {(<span class="math inline"><em>i</em></span>,<span class="math inline"><em>j</em></span>) s.t. <span class="math inline"><em>i</em>, <em>j</em> ∈ <em>P</em></span>} denote the set of channels.</p>
<p>A local state of a process <span class="math inline"><em>i</em></span> is denoted by <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</p>
<p>A local state consists of a sequence of event blocks <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup> = <em>v</em><sub>0</sub><sup><em>i</em></sup>, <em>v</em><sub>1</sub><sup><em>i</em></sup>, …, <em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</p>
<p>In a DAG-based protocol, each <span class="math inline"><em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span> event block is valid only the reference blocks exist exist before it. From a local state <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span>, one can reconstruct a unique DAG. That is, the mapping from a local state <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span> into a DAG is <em>injective</em> or one-to-one. Thus, for Lachesis, we can simply denote the <span class="math inline"><em>j</em></span>-th local state of a process <span class="math inline"><em>i</em></span> by the OPERA chain <span class="math inline"><em>g</em><sub><em>j</em></sub><sup><em>i</em></sup></span> (often we simply use <span class="math inline"><em>G</em><sub><em>i</em></sub></span> to denote the current local state of a process <span class="math inline"><em>i</em></span>).</p>
<p>An action is a function from one local state to another local state.</p>
<p>Generally speaking, an action can be either: a <span class="math inline"><em>s</em><em>e</em><em>n</em><em>d</em>(<em>m</em>)</span> action where <span class="math inline"><em>m</em></span> is a message, a <span class="math inline"><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em>(<em>m</em>)</span> action, and an internal action. A message <span class="math inline"><em>m</em></span> is a triple <span class="math inline">⟨<em>i</em>, <em>j</em>, <em>B</em>⟩</span> where <span class="math inline"><em>i</em> ∈ <em>P</em></span> is the sender of the message, <span class="math inline"><em>j</em> ∈ <em>P</em></span> is the message recipient, and <span class="math inline"><em>B</em></span> is the body of the message. Let <span class="math inline"><em>M</em></span> denote the set of messages. In Lachesis protocol, <span class="math inline"><em>B</em></span> consists of the content of an event block <span class="math inline"><em>v</em></span>. Semantics-wise, in Lachesis, there are two actions that can change a process’s local state: creating a new event and receiving an event from another process.</p>
<p>An event is a tuple <span class="math inline">⟨<em>s</em>, <em>α</em>, <em>s</em>′⟩</span> consisting of a state, an action, and a state.</p>
<p>Sometimes, the event can be represented by the end state <span class="math inline"><em>s</em>′</span>. The <span class="math inline"><em>j</em></span>-th event in history <span class="math inline"><em>h</em><sub><em>i</em></sub></span> of process <span class="math inline"><em>i</em></span> is <span class="math inline">⟨<em>s</em><sub><em>j</em> − 1</sub><sup><em>i</em></sup>, <em>α</em>, <em>s</em><sub><em>j</em></sub><sup><em>i</em></sup>⟩</span>, denoted by <span class="math inline"><em>v</em><sub><em>j</em></sub><sup><em>i</em></sup></span>.</p>
<p>A local history <span class="math inline"><em>h</em><sub><em>i</em></sub></span> of process <span class="math inline"><em>i</em></span> is a (possibly infinite) sequence of alternating local states — beginning with a distinguished initial state. A set <span class="math inline"><em>H</em><sub><em>i</em></sub></span> of possible local histories for each process <span class="math inline"><em>i</em></span> in <span class="math inline"><em>P</em></span>.</p>
<p>The state of a process can be obtained from its initial state and the sequence of actions or events that have occurred up to the current state. In Lachesis protocol, we use append-only sematics. The local history may be equivalently described as either of the following: <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>α</em><sub>1</sub><sup><em>i</em></sup>, <em>α</em><sub>2</sub><sup><em>i</em></sup>, <em>α</em><sub>3</sub><sup><em>i</em></sup>…</span><br /> <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>v</em><sub>1</sub><sup><em>i</em></sup>, <em>v</em><sub>2</sub><sup><em>i</em></sup>, <em>v</em><sub>3</sub><sup><em>i</em></sup>…</span><br /> <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>s</em><sub>0</sub><sup><em>i</em></sup>, <em>s</em><sub>1</sub><sup><em>i</em></sup>, <em>s</em><sub>2</sub><sup><em>i</em></sup>, <em>s</em><sub>3</sub><sup><em>i</em></sup>, …</span><br /></p>
<p>In Lachesis, a local history is equivalently expressed as: <br /><span class="math display"><em>h</em><sub><em>i</em></sub> = <em>g</em><sub>0</sub><sup><em>i</em></sup>, <em>g</em><sub>1</sub><sup><em>i</em></sup>, <em>g</em><sub>2</sub><sup><em>i</em></sup>, <em>g</em><sub>3</sub><sup><em>i</em></sup>, …</span><br /> where <span class="math inline"><em>g</em><sub><em>j</em></sub><sup><em>i</em></sup></span> is the <span class="math inline"><em>j</em></span>-th local OPERA chain (local state) of the process <span class="math inline"><em>i</em></span>.</p>
<p>Each asynchronous run is a vector of local histories. Denoted by <span class="math inline"><em>σ</em> = ⟨<em>h</em><sub>1</sub>, <em>h</em><sub>2</sub>, <em>h</em><sub>3</sub>, ...<em>h</em><sub><em>N</em></sub>⟩</span>.</p>
<p>Let <span class="math inline"><em>Σ</em></span> denote the set of asynchronous runs.</p>
<p>We can now use Lamport’s theory to talk about global states of an asynchronous system. A global state of run <span class="math inline"><em>σ</em></span> is an <span class="math inline"><em>n</em></span>-vector of prefixes of local histories of <span class="math inline"><em>σ</em></span>, one prefix per process. The happens-before relation can be used to define a consistent global state, often termed a consistent cut, as follows.</p>
<p>A consistent cut of a run <span class="math inline"><em>σ</em></span> is any global state such that if <span class="math inline"><em>v</em><sub><em>x</em></sub><sup><em>i</em></sup> → <em>v</em><sub><em>y</em></sub><sup><em>j</em></sup></span> and <span class="math inline"><em>v</em><sub><em>y</em></sub><sup><em>j</em></sup></span> is in the global state, then <span class="math inline"><em>v</em><sub><em>x</em></sub><sup><em>i</em></sup></span> is also in the global state. Denoted by <span class="math inline"><strong>c</strong>(<em>σ</em>)</span>.</p>
<p>By Theorem [thm:conchains], all nodes have consistent local OPERA chains. The concept of consistent cut formalizes such a global state of a run. A consistent cut consists of all consistent OPERA chains. A received event block exists in the global state implies the existence of the original event block. Note that a consistent cut is simply a vector of local states; we will use the notation <span class="math inline"><strong>c</strong>(<em>σ</em>)[<em>i</em>]</span> to indicate the local state of <span class="math inline"><em>i</em></span> in cut <span class="math inline"><strong>c</strong></span> of run <span class="math inline"><em>σ</em></span>.</p>
<p>The formal semantics of an asynchronous system is given via the satisfaction relation <span class="math inline">⊢</span>. Intuitively <span class="math inline"><strong>c</strong>(<em>σ</em>)⊢<em>ϕ</em></span>, “<span class="math inline"><strong>c</strong>(<em>σ</em>)</span> satisfies <span class="math inline"><em>ϕ</em></span>,” if fact <span class="math inline"><em>ϕ</em></span> is true in cut <span class="math inline"><strong>c</strong></span> of run <span class="math inline"><em>σ</em></span>. We assume that we are given a function <span class="math inline"><em>π</em></span> that assigns a truth value to each primitive proposition <span class="math inline"><em>p</em></span>. The truth of a primitive proposition <span class="math inline"><em>p</em></span> in <span class="math inline"><strong>c</strong>(<em>σ</em>)</span> is determined by <span class="math inline"><em>π</em></span> and <span class="math inline"><strong>c</strong></span>. This defines <span class="math inline"><strong>c</strong>(<em>σ</em>)⊢<em>p</em></span>.</p>
<p>Two cuts <span class="math inline"><strong>c</strong>(<em>σ</em>)</span> and <span class="math inline"><strong>c</strong><strong>′</strong>(<em>σ</em>′)</span> are equivalent with respect to <span class="math inline"><em>i</em></span> if: <br /><span class="math display"><strong>c</strong>(<em>σ</em>)∼<sub><em>i</em></sub><strong>c</strong><strong>′</strong>(<em>σ</em>′) ⇔ <strong>c</strong>(<em>σ</em>)[<em>i</em>]=<strong>c</strong><strong>′</strong>(<em>σ</em>′)[<em>i</em>]</span><br /></p>
<p>We introduce two families of modal operators, denoted by <span class="math inline"><em>K</em><sub><em>i</em></sub></span> and <span class="math inline"><em>P</em><sub><em>i</em></sub></span>, respectively. Each family indexed by process identifiers. Given a fact <span class="math inline"><em>ϕ</em></span>, the modal operators are defined as follows:</p>
<p><span class="math inline"><em>K</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> represents the statement “<span class="math inline"><em>ϕ</em></span> is true in all possible consistent global states that include <span class="math inline"><em>i</em></span>’s local state”. <br /><span class="math display"><strong>c</strong>(<em>σ</em>)⊢<em>K</em><sub><em>i</em></sub>(<em>ϕ</em>)⇔∀<strong>c</strong><strong>′</strong>(<em>σ</em>′)(<strong>c</strong><strong>′</strong>(<em>σ</em>′)∼<sub><em>i</em></sub><strong>c</strong>(<em>σ</em>)  ⇒  <strong>c</strong><strong>′</strong>(<em>σ</em>′) ⊢ <em>ϕ</em>)</span><br /></p>
<p><span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> represents the statement “there is some consistent global state in this run that includes <span class="math inline"><em>i</em></span>’s local state, in which <span class="math inline"><em>ϕ</em></span> is true.” <br /><span class="math display"><strong>c</strong>(<em>σ</em>)⊢<em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)⇔∃<strong>c</strong><strong>′</strong>(<em>σ</em>)(<strong>c</strong><strong>′</strong>(<em>σ</em>)∼<sub><em>i</em></sub><strong>c</strong>(<em>σ</em>)  ∧  <strong>c</strong><strong>′</strong>(<em>σ</em>)⊢<em>ϕ</em>)</span><br /></p>
<p>The next modal operator is written <span class="math inline"><em>M</em><sup><em>C</em></sup></span> and stands for “majority concurrently knows.” This is adapted from the “everyone concurrently knows” in CCK paper <span class="citation"></span>. The definition of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is as follows.</p>
<p><br /><span class="math display"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)=<sub><em>d</em><em>e</em><em>f</em></sub>⋀<sub><em>i</em> ∈ <em>S</em></sub><em>K</em><sub><em>i</em></sub><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>),</span><br /> where <span class="math inline"><em>S</em> ⊆ <em>P</em></span> and <span class="math inline">|<em>S</em>|&gt;2<em>n</em>/3</span>.</p>
<p>In the presence of one-third of faulty nodes, the original operator “everyone concurrently knows” is sometimes not feasible. Our modal operator <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> fits precisely the semantics for BFT systems, in which unreliable processes may exist.</p>
<p>The last modal operator is concurrent common knowledge (CCK), denoted by <span class="math inline"><em>C</em><sup><em>C</em></sup></span>.</p>
<p><span class="math inline"><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is defined as a fixed point of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span></p>
<p>CCK defines a state of process knowledge that implies that all processes are in that same state of knowledge, with respect to <span class="math inline"><em>ϕ</em></span>, along some cut of the run. In other words, we want a state of knowledge <span class="math inline"><em>X</em></span> satisfying: <span class="math inline"><em>X</em> = <em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span>. <span class="math inline"><em>C</em><sup><em>C</em></sup></span> will be defined semantically as the weakest such fixed point, namely as the greatest fixed-point of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>X</em>)</span>. It therefore satisfies: <br /><span class="math display"><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)⇔<em>M</em><sup><em>C</em></sup>(<em>ϕ</em> ∧ <em>C</em><sup><em>C</em></sup>(<em>ϕ</em>))</span><br /></p>
<p>Thus, <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> states that there is some cut in the same asynchronous run <span class="math inline"><em>σ</em></span> including <span class="math inline"><em>i</em></span>’s local state, such that <span class="math inline"><em>ϕ</em></span> is true in that cut.</p>
<p>Note that <span class="math inline"><em>ϕ</em></span> implies <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span>. But it is not the case, in general, that <span class="math inline"><em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)</span> implies <span class="math inline"><em>ϕ</em></span> or even that <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> implies <span class="math inline"><em>ϕ</em></span>. The truth of <span class="math inline"><em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is determined with respect to some cut <span class="math inline"><strong>c</strong>(<em>σ</em>)</span>. A process cannot distinguish which cut, of the perhaps many cuts that are in the run and consistent with its local state, satisfies <span class="math inline"><em>ϕ</em></span>; it can only know the existence of such a cut.</p>
<p>Fact <span class="math inline"><em>ϕ</em></span> is valid in system <span class="math inline"><em>Σ</em></span>, denoted by <span class="math inline"><em>Σ</em> ⊢ <em>ϕ</em></span>, if <span class="math inline"><em>ϕ</em></span> is true in all cuts of all runs of <span class="math inline"><em>Σ</em></span>. <br /><span class="math display"><em>Σ</em> ⊢ <em>ϕ</em> ⇔ (∀<em>σ</em> ∈ <em>Σ</em>)(∀<strong>c</strong>)(<strong>c</strong>(<em>a</em>)⊢<em>ϕ</em>)</span><br /></p>
<p>Fact <span class="math inline"><em>ϕ</em></span> is valid, denoted <span class="math inline">⊢<em>ϕ</em></span>, if <span class="math inline"><em>ϕ</em></span> is valid in all systems, i.e. <span class="math inline">(∀<em>Σ</em>)(<em>Σ</em> ⊢ <em>ϕ</em>)</span>.</p>
<p>A fact <span class="math inline"><em>ϕ</em></span> is local to process <span class="math inline"><em>i</em></span> in system <span class="math inline"><em>Σ</em></span> if <span class="math inline"><em>Σ</em> ⊢ (<em>ϕ</em> ⇒ <em>K</em><sub><em>i</em></sub><em>ϕ</em>)</span></p>
<p>If <span class="math inline"><em>ϕ</em></span> is local to process <span class="math inline"><em>i</em></span> in system <span class="math inline"><em>Σ</em></span>, then <span class="math inline"><em>Σ</em> ⊢ (<em>P</em><sub><em>i</em></sub>(<em>ϕ</em>)⇒<em>ϕ</em>)</span>.</p>
<p>If fact <span class="math inline"><em>ϕ</em></span> is local to 2/3 of the processes in a system <span class="math inline"><em>Σ</em></span>, then <span class="math inline"><em>Σ</em> ⊢ (<em>M</em><sup><em>C</em></sup>(<em>ϕ</em>)⇒<em>ϕ</em>)</span> and furthermore <span class="math inline"><em>Σ</em> ⊢ (<em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)⇒<em>ϕ</em>)</span>.</p>
<p>A fact <span class="math inline"><em>ϕ</em></span> is attained in run <span class="math inline"><em>σ</em></span> if <span class="math inline">∃<strong>c</strong>(<em>σ</em>)(<strong>c</strong>(<em>σ</em>)⊢<em>ϕ</em>)</span>.</p>
<p>Often, we refer to “knowing” a fact <span class="math inline"><em>ϕ</em></span> in a state rather than in a consistent cut, since knowledge is dependent only on the local state of a process. Formally, <span class="math inline"><em>i</em></span> knows <span class="math inline"><em>ϕ</em></span> in state <span class="math inline"><em>s</em></span> is shorthand for <br /><span class="math display">∀<strong>c</strong>(<em>σ</em>)(<strong>c</strong>(<em>σ</em>)[<em>i</em>]=<em>s</em> ⇒ <strong>c</strong>(<em>σ</em>)⊢<em>ϕ</em>)</span><br /></p>
<p>For example, if a process in Lachesis protocol knows a fork exists (i.e., <span class="math inline"><em>ϕ</em></span> is the exsistenc of fork) in its local state <span class="math inline"><em>s</em></span> (i.e., <span class="math inline"><em>g</em><sub><em>j</em></sub><sup><em>i</em></sup></span>), then a consistent cut contains the state <span class="math inline"><em>s</em></span> will know the existence of that fork.</p>
<p>Process <span class="math inline"><em>i</em></span> learns <span class="math inline"><em>ϕ</em></span> in state <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span> of run <span class="math inline"><em>σ</em></span> if <span class="math inline"><em>i</em></span> knows <span class="math inline"><em>ϕ</em></span> in <span class="math inline"><em>s</em><sub><em>j</em></sub><sup><em>i</em></sup></span> and, for all previous states <span class="math inline"><em>s</em><sub><em>k</em></sub><sup><em>i</em></sup></span> in run <span class="math inline"><em>σ</em></span>, <span class="math inline"><em>k</em> &lt; <em>j</em></span>, <span class="math inline"><em>i</em></span> does not know <span class="math inline"><em>ϕ</em></span>.</p>
<p>The following theorem says that if <span class="math inline"><em>C</em><sub><em>C</em></sub>(<em>ϕ</em></span> is attained in a run then all processes <span class="math inline"><em>i</em></span> learn <span class="math inline"><em>P</em><sub><em>i</em></sub><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> along a single consistent cut.</p>
<p>If <span class="math inline"><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> is attained in a run <span class="math inline"><em>σ</em></span>, then the set of states in which all processes learn <span class="math inline"><em>P</em><sub><em>i</em></sub><em>C</em><sup><em>C</em></sup>(<em>ϕ</em>)</span> forms a consistent cut in <span class="math inline"><em>σ</em></span>.</p>
<p>We have presented a formal semantics of Lachesis protocol based on the concepts and notations of concurrent common knowledge <span class="citation"></span>. For a proof of the above theorems and lemmas in this Section, we can use similar proofs as described in the original CCK paper.</p>
<p>With the formal semantics of Lachesis, the theorems and lemmas described in Section [se:proof] can be expressed in term of CCK. For example, one can study a fact <span class="math inline"><em>ϕ</em></span> (or some primitive proposition <span class="math inline"><em>p</em></span>) in the following forms: ‘is there any existence of fork?’. One can make Lachesis-specific questions like ’is event block <span class="math inline"><em>v</em></span> a root?’, ’is <span class="math inline"><em>v</em></span> a clotho?’, or ’is <span class="math inline"><em>v</em></span> a atropos?’. This is a remarkable result, since we are the first that define such a formal semantics for DAG-based protocol.</p>
<h1 id="se:ref">Reference</h1>
